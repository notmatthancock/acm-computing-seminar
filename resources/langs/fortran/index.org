#+title: ACM Computing Seminar Fortran Guide
#+author: Joseph P. McKenna
#+email: joepatmckenna@gmail.com
#+property: header-args :mkdirp yes :cache yes
#+property: header-args:fortran :exports code :results output
#+property: header-args:sh :exports both
#+startup: latexpreview
#+options: html-postamble:nil
#+html_head: <link rel="stylesheet" type="text/css" href="../css/main.css">
#+html_head: <link rel="stylesheet" type="text/css" href="../css/fortran.css">
#+html_head: <script src="../js/main.js"></script>
#+html: <div id="main">
#+html: <div id="footer"><a href="../../../">ACM Computing Seminar Home</a> &mdash; This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.</div>
#+html: <a href="javascript:;" id="toc-open">&#9776;</a>
#+html: <a href="javascript:;" id="toc-close">&times;</a>

:snippets:
# * ${n \choose k}$
# #+begin_src fortran :tangle choose/main.f90
#   program main
#     implicit none
#     print*, choose(4,0), choose(4,1), &
#          choose(4,2), choose(4,3), choose(4,4)
#   contains
#     function choose(n,k) result(c)
#       integer, intent(in) :: n, k
#       integer :: c, i
#       c = 1
#       do i = 1, min(k,n-k)
#          c = c * (n-i+1) / i
#       end do
#     end function choose
#   end program main
# #+end_src

# #+begin_src sh :dir choose
# gfortran main.f90 -o main
# #+end_src

# #+begin_src sh :dir choose
# ./main
# #+end_src

# * Setting precision of variables
# #+begin_src fortran :tangle precision/constants.f90
#   module constants
#     implicit none
#     integer, parameter :: sp = kind(0.), dp = kind(0.d0)
#     integer, parameter :: rp = dp
#   end module constants
# #+end_src

# #+begin_src sh :dir precision
# gfortran -c constants.f90
# #+end_src

# #+begin_src fortran :tangle precision/main.f90
#   program main
#     use constants
#     implicit none
#     real(rp) :: x, y
#     x = 1._rp
#     y = real(1,rp)
#   end program main
# #+end_src

# #+begin_src sh :dir precision
# gfortran main.f90 constants.o -o main
# #+end_src

# #+begin_src sh :dir precision
# ./main
# #+end_src

# #+begin_src make :exports none :tangle precision/makefile
#   FC = gfortran
#   SRC = main.f90
#   EXE = main
#   OBJ = constants.o

#   all: $(EXE)
#   $(EXE): $(OBJ)
#     $(FC) $(OBJ) $(SRC) -o $(EXE) 
#   %.o: %.f90
#     $(FC) -c $< -o $@
#   clean:
#     $(RM) *.o $(EXE)
# #+end_src

# * Machine Epsilon
# #+begin_src fortran :tangle epsilon/constants.f90
#   module constants
#     implicit none

#     integer, parameter :: sp = kind(0.), dp = kind(0.d0)
#     integer, parameter :: rp = dp

#     interface machine_epsilon
#        module procedure machine_epsilon_sp, machine_epsilon_dp
#     end interface machine_epsilon

#   contains

#     function machine_epsilon_sp(x) result(e)
#       implicit none
#       real(sp), intent(in) :: x
#       real :: e
#       e = .5
#       do while (1._sp + e > 1._sp)
#          e = .5 * e
#       end do
#     end function machine_epsilon_sp

#     function machine_epsilon_dp(x) result(e)
#       implicit none
#       real(dp), intent(in) :: x
#       real :: e
#       e = .5
#       do while (1._dp + e > 1._dp)
#          e = .5 * e
#       end do
#     end function machine_epsilon_dp

#   end module constants
# #+end_src

# #+begin_src sh :dir epsilon
# gfortran -c constants.f90
# #+end_src

# #+begin_src fortran :tangle epsilon/main.f90
#   program main
#     use constants
#     implicit none
#     print*, machine_epsilon(0._sp), machine_epsilon(0._dp)
#   end program main
# #+end_src

# #+begin_src sh :dir epsilon
# gfortran main.f90 constants.o -o main
# #+end_src
 
# #+begin_src sh :dir epsilon
# ./main
# #+end_src

# #+begin_src make :exports none :tangle epsilon/makefile
#   FC = gfortran
#   SRC = main.f90
#   EXE = main
#   OBJ = constants.o

#   all: $(EXE)
#   $(EXE): $(OBJ)
#     $(FC) $(OBJ) $(SRC) -o $(EXE) 
#   %.o: %.f90
#     $(FC) -c $< -o $@
#   clean:
#     $(RM) *.o $(EXE)
# #+end_src

# #+begin_src fortran :exports both
#   print*, epsilon(0.), epsilon(0.d0)
# #+end_src

# * Rootfinding

# #+begin_src fortran :tangle rootfind/functions.f90
#   module functions
#     implicit none

#   contains

#     function f1(x)
#       real, intent(in) :: x
#       real :: f1
#       f1 = sin(x)
#     end function f1

#     function df1dx(x)
#       real, intent(in) :: x
#       real :: df1dx
#       df1dx = cos(x)
#     end function df1dx

#   end module functions
# #+end_src

# #+begin_src sh :dir rootfind
# gfortran -c functions.f90
# #+end_src

# #+begin_src fortran :tangle rootfind/rootfind.f90
#   module rootfind
#     implicit none

#     interface
#        function fun(x)
#          real, intent(in) :: x
#          real :: fun
#        end function fun
#     end interface

#   contains

#     function newton(f,dfdx,x0,tol,maxstep) result(xn)
#       procedure(fun), pointer :: f, dfdx
#       real, intent(in) :: x0, tol
#       integer, intent(in) :: maxstep
#       real :: xn
#       integer :: n = 0

#       xn = x0
#       do while (abs(f(xn))>tol .and. n<maxstep)
#          xn = xn - f(xn)/dfdx(xn)
#          n = n + 1
#       end do
#     end function newton

#   end module rootfind
# #+end_src

# #+begin_src sh :dir rootfind
# gfortran -c rootfind.f90
# #+end_src

# #+begin_src fortran :tangle rootfind/main.f90
#   program main
#   	use functions
#     use rootfind
#     implicit none

#     procedure(fun), pointer :: f, dfdx
#     real :: x = 1., tol = 1e-5
#     integer :: maxstep = 100
#     f => f1
#     dfdx => df1dx
#     print*, newton(f,dfdx,x,tol,maxstep)

#   end program main
# #+end_src

# #+begin_src sh :dir rootfind
# gfortran main.f90 functions.o rootfind.o -o main
# #+end_src

# #+begin_src make :exports none :tangle rootfind/makefile
#   FC = gfortran
#   SRC = main.f90
#   EXE = main
#   OBJ = functions.o rootfind.o

#   all: $(EXE)
#   $(EXE): $(OBJ)
#     $(FC) $(OBJ) $(SRC) -o $(EXE) 
#   %.o: %.f90
#     $(FC) -c $< -o $@
#   clean:
#     $(RM) *.o $(EXE)
# #+end_src

# #+begin_src sh :dir rootfind
# ./main
# #+end_src

# * Quadrature

# #+begin_src fortran :tangle quadrature/functions.f90
#   module functions
#     implicit none

#   contains

#     function f1(x)
#       real, intent(in) :: x
#       real :: f1
#       f1 = x
#     end function f1

#   end module functions
# #+end_src

# #+begin_src sh :dir quadrature
#   gfortran -c functions.f90
# #+end_src

# #+begin_src fortran :tangle quadrature/quadrature.f90
#   module quadrature
#     implicit none

#   contains

#     function midpoint_rule(f,a,b,n) result(I)
#       interface
#          function f(x)
#            real, intent(in) :: x
#            real :: f
#          end function f
#       end interface
#       real :: a, b
#       integer :: n, j
#       real :: I, dx

#       dx = (b-a)/real(n)
#       I = 0
#       do j = 0,n-1
#          I = I + f(a + (j+.5)*dx)
#       end do
#       I = dx*I
#     end function midpoint_rule

#   end module quadrature
# #+end_src

# #+begin_src sh :dir quadrature
#   gfortran -c quadrature.f90
# #+end_src

# #+begin_src fortran :tangle quadrature/main.f90
#   program main
#     use functions
#     use quadrature
#     implicit none

#     real :: a = 0, b = 1
#     integer :: n = 5
#     print*, midpoint_rule(f1,a,b,n)

#   end program main
# #+end_src

# #+begin_src sh :dir quadrature
#   gfortran main.f90 functions.o quadrature.o -o main
# #+end_src

# #+begin_src make :exports none :tangle quadrature/makefile
#   FC = gfortran
#   SRC = main.f90
#   EXE = main
#   OBJ = functions.o quadrature.o

#   all: $(EXE)
#   $(EXE): $(OBJ)
#     $(FC) $(OBJ) $(SRC) -o $(EXE) 
#   %.o: %.f90
#     $(FC) -c $< -o $@
#   clean:
#     $(RM) *.o $(EXE)
# #+end_src

# #+begin_src sh :dir quadrature
#   ./main
# #+end_src

# * Matrix multiplication
# #+begin_src fortran :exports both :tangle matmul/main.f90
#   program main
#     implicit none

#     real :: A(4,4), B(4,4)
#     A=1; B=2

#     print*, matrix_multiply(A,B)

#   contains

#     function matrix_multiply(A,B) result(C)
#       implicit none
#       real :: A(4,4), B(4,4), C(4,4)
#       integer :: i,j,k

#       C = 0
#       do i=1,4
#          do j=1,4
#             do k=1,4
#                C(i,j) = C(i,j) + A(i,k)*B(k,j)
#             end do
#          end do
#       end do

#       end function matrix_multiply

#   end program main
# #+end_src
# * $\sum_{n=0}^{\infty}\frac1{n!}$
# #+begin_src fortran :exports both :tangle series/main.f90
#   program main
#     implicit none
#     integer :: n = 0, nf = 1
#     real :: s = 0
#     do while (1./real(nf) > 0)
#        s = s + 1./real(nf)
#        n = n + 1
#        nf = nf * n
#     end do
#     print*, s, exp(1.)-s
#   end program main
# #+end_src
:end:

* Introduction
This guide is intended to quickly get you up-and-running in scientific computing with Fortran. There is a companion [[../cpp/index.html][C++ guide]] that parallels the content of this guide. 
** About the language
Fortran was created in the 1950s for mathematical *FOR*-mula *TRAN*-slation, and has since gone through a number of revisions (FORTRAN 66, 77, and Fortran 90, 95, 2003, 2008, 2015). The language standards are put forth by the Fortran standards committee [[http://www.j3-fortran.org][J3]] in a document (ISO 1539-1:2010) available for purchase. The syntax and intrinsic capabilities of the language make it especially suited for scientific computing. Like C/C++, Fortran is a *statically-typed* and *compiled* language. You must declare the *type*, i.e. integer, real number, etc. of variables in programs you write. Your programs will be translated from human-readable /source code/ into a machine-executable file by software called a *compiler*. Fortran is *not case-sensitive*, so =matrix= and =MaTrIx= are translated to the same token by the compiler.

* Getting started
The software that you need to get started comes prepackaged and ready to download on most Linux distributions. There are a few options for emulating a Linux environment in Windows or Mac OS, such as a virtual machine (VirtualBox) or package manager (MinGW or Cygwin on Windows and Brew on Mac OS).
** Text editor
You will write the source code of your programs using a text editor. There are many options that have features designed for programming such as syntax highlighting and auto-completion. If you are an impossible-to-please perfectionist, you might want to check out [[https://www.gnu.org/s/emacs/][Emacs]]. If you are easier to please, you might want to check out [[https://www.sublimetext.com/][Sublime Text]].
** Compiler
To translate your source code into an executable, you will need a Fortran compiler. A free option is *gfortran*, part of the GNU compiler collection (gcc). The features of the Fortran language that are supported by the =gfortran= compiler are specified in the [[https://gcc.gnu.org/onlinedocs/gfortran/][compiler documentation]]. This is your most complete reference for the intrinsic capabilities of Fortran that your programs can use. At the time of this writing, =gfortran= completely supports Fortran 95 and partially supports more recent standards.
** Writing a program
*** Hello world
Let's write a tiny program that prints "hello world" to the terminal screen in =hello.f90=

#+begin_src fortran -n :tangle hello/hello.f90
program main
  print*, 'hello world'
end program main
#+end_src

To compile the program, execute the following command in the same directory as =hello.f90=

#+begin_src sh :dir hello
gfortran hello.f90
#+end_src

This produces an executable file named =a.out= by default (On Windows, this is probably named =a.exe= by default). To run, execute the file.

#+begin_src sh :dir hello
./a.out
#+end_src

We could have specified a different name for the executable file during compilation with the =-o= option of =gfortran=.

#+begin_src sh :dir hello
gfortran hello.f90 -o my_executable_file
#+end_src

On Windows, you should append the =.exe= extension to =my_executable_file=.

*** Template
Now let's write an empty template for future projects. This section may seem overly complex at first read, but it is best to adopt some form of organization when you are just getting started. Our source code template will consist of two files in the same directory ([[./template/]]). In the following files, the contents of a line after a =!= symbol is a comment that is ignored by the compiler. One file =header.f90= is a *module* that defines things to be used in the main program.

#+begin_src fortran -n -r :tangle template/header.f90
module header
  implicit none (ref:in1)
  ! variable declarations and assignments
contains
  ! function and subroutine definitions
end module header
#+end_src

This file is compiled into an *object file* with the =-c= option of =gfortran=

#+begin_src sh :dir template
gfortran -c header.f90
#+end_src

This outputs the object file named =header.o= by default that can be /linked/ to the main program. A separate file =main.f90= contains the main program.

#+begin_src fortran -n -r :tangle template/main.f90
program main
  use header (ref:u)
  implicit none (ref:in2)
  ! variable declarations and assignments
  ! function and subroutine calls
contains
  ! function and subroutine definitions
end program main
#+end_src

On line [[(u)]] of =main.f90=, we instruct the main program to use things defined in =header.f90=, so we must link the object file =header.o= when compiling =main.f90=.

#+begin_src sh :dir template
gfortran main.f90 header.o -o main
#+end_src

To run the program, execute the output file =main= in the same directory.

#+begin_src sh :dir template
./main
#+end_src

As you get more experience, you will find it very cumbersome to repeatedly execute =gfortran= commands with every modification to your code. Using the =make= command-line utility is a way around this. You can specify all the compilation commands for your project in a file named =makefile=. For example, the template above could use the following =makefile=.

#+begin_src make -n -r :tangle template/makefile
FC = gfortran
SRC = main.f90
EXE = main
OBJ = header.o(ref:obj)

all: $(EXE)
$(EXE): $(OBJ)
	$(FC) $(SRC) $(OBJ) -o $(EXE)
%.o: %.f90
	$(FC) -c $< -o $@
#+end_src

Then, to recompile both =header.f90= and =main.f90= after modifying either file, execute

#+begin_src sh :exports code :dir template
make
#+end_src

in the same directory. The first four lines of =makefile= assign variables for the compiler command, file name of the main program, file name of the executable to be created, and file name(s) of linked object file(s), respectively. If you wrote a second module in a separate file =my_second_header.f90= that you wanted to =use= in =main.f90=, you would modify line [[(obj)]] of =makefile= to =OBJ = header.o my_second_header.o=. The remaining lines contain instructions for compilation.

** Exercises
1. Compile and run =hello.f90=.
2. Execute =man gfortran= in any directory to bring up the manual for =gfortran=. Read the description and skim through the options. Do the same for =make=.

* Data types
In each program element, the data types of variables are declared first, preceding complex variable assignments and other procedures.

We will use the =implicit none= keyword at the beginning of each program and module as in line [[(in1)]] of =header.f90= and line [[(in2)]] of =main.f90= in Section [[Template]]. The role of this keyword is to suppress some implicit rules that Fortran has for undeclared variables, and by including it we force ourselves to declare each variable that we use. This means our code will be slightly longer than necessary but it will facilitate debugging when our program fails to compile. Without the =implicit none= keyword, an undeclared variable with a name such as =i= is assumed to be an integer data type whereas an undeclared variable with a name such as =x= is assumed to be a real data type.

In addition to the most common data types presented below, Fortran has a =complex= data type and support for user-defined data types.

** The =logical= type
A variable of the =logical= type can have values =.true.= or =.false.=. Logical expressions can be computed with a few operators 

#+begin_src fortran -n 
logical :: a,b,c
a = .true.
b = .false.

! '.not.' is the logical negation operator
c = .not.a ! c is false

! '.and,' is the logical and operator
c = a.and.b ! c is false

! '.or.' is the logical or operator
c = a.or.b ! c is true

! '==' is the test for equality
c = (1 == 2) ! c is false

! '/=' is test for inequality
c = (1 /= 2) ! c is true
#+end_src

#+RESULTS[aafe5eb2ce157c09b1e0faff1d07c64e2138c81b]:

Other logical operators include
- =<= or =.lt.=: less than
- =<== or =.le.=: less than or equal
- =>= or =.gt.=: greater than
- =>== or =.ge.=: greater than or equal

Logical expressions are often used in [[Control structures][control structures]].

** The =integer= type
An =integer= data type can hold integer values. If a real value is assigned to an =integer= type, the decimal portion is truncated.

#+begin_src fortran -n
integer :: a = 6, b = 7 ! initialize a and b to 6 and 7, resp
integer :: c

c = a / b ! c is 0
c = b / a ! c is 1
c = a + b ! c is 13
c = b - a ! c is -1
c = a*b ! c is 42
c = a**b ! c is 6^7
c = mod(b,a) ! c is 1, 'mod' is the modulo operator
c = a > b ! c is 0 (logical gets cast to integer)
c = a < b ! c is 1 (logical gets cast to integer)
#+end_src

** Floating point types
The two floating point data types =real= and =double precision= correspond to [[https://en.wikipedia.org/wiki/IEEE_floating_point][IEEE 32- and 64-bit floating point data types]]. A constant called /machine epsilon/ is the smallest number in a floating point system that when added to 1 results in a floating point number larger than 1. It is used in a lot of numerical analysis error estimates. 

#+begin_src fortran -n :exports both :results output
real :: a ! declare a single precision float
double precision :: b ! declare a double precision float

! Print the min/max value of single precision float
! and machine epsilon for the single precision floating point system
print*, tiny(a), huge(a), epsilon(a)

! Print the min/max value of a double precision float
! and machine epsilon for the double precision floating point system
print*, tiny(b), huge(b), epsilon(b)
#+end_src

#+RESULTS[45ea6a3e832d9c6a899dc779e2e66766e89492d4]:
: 1.17549435E-38   3.40282347E+38   1.19209290E-07
: 2.2250738585072014E-308   1.7976931348623157E+308   2.2204460492503131E-016

** The =character= type
A =character= data type is used to store letters. The maximum length of a character string is specified with a positive =integer= argument at declaration.

#+begin_src fortran -n :exports both :results output
! declare a character variable s at most 32 characters
character(32) :: s

! assign value to s
s = 'file_name'

! trim trailing spaces from s and
! append a character literal '.dat'
print*, trim(s) // '.txt'
#+end_src

#+RESULTS[93961e2b9ba8076aca493c454705d660c4c13cad]:
: file_name.txt

** Casting
An =integer= can be cast to a =real= or vice versa.

#+begin_src fortran -n
integer :: a = 1, b
real :: c, PI = 3.14159

! explicit cast real to int
b = int(PI) ! b is 3

! implicit cast real to int
c = a/b ! c is 0

! explicit cast int to real and divide
c = a/real(b) ! c is .3333...
#+end_src

** The =parameter= modifier
The =parameter= keyword is used to declare constant variables. When a variable is declared with the =parameter= keyword, it must be assigned a value at declaration and that value cannot be reassigned later. The following code is not valid because of the reassignment =PI = 3=.

#+begin_src fortran -n
! declare constant
real, parameter :: PI = 2.*asin(1.) ! 'asin' is arcine function
! attempt to reassign value
PI = 3
#+end_src

The compiler produces an error like =Error: Named constant ‘pi’ in variable definition context (assignment)=.

** Setting the precision
The =kind= function returns an =integer= for each data type. The =kind= of a floating point number can be specified at declaration. We could work in either single or double precision by storing the =kind= of a =real= or =double precision=, resp., in a constant =rp= then declaring each new variable with that =kind=. Then, to switch precision, we would only need to switch =rp=.

#+begin_src fortran -n
real :: r ! declare a real, single precision by default
double precision :: d ! declare a double precision
integer, parameter :: sp = kind(r), dp = kind(d) ! store kinds of r and d
integer, parameter :: rp = sp ! set current kind

! declare real b in double precision
real(dp) :: b

! declare real a with precision kind rp
real(rp) :: a

! cast 1 to real with precision kind rp and assign to a
a = 1.0_rp

! cast b to real with precision kind rp and assign to a
a = real(b,rp)
#+end_src

** Pointers
Pointers have the same meaning in Fortran as in C++. A pointer is a variable that holds the *memory address* of a variable. The implementation of pointers is qualitatively different in Fortran than in C++. In Fortran, the user cannot view the memory address that a pointer stores. A pointer variable is declared with the =pointer= modifier, and a variable that it points to is declared with the =target= modifier. The types of a =pointer= and its =target= must match.

#+begin_src fortran -n :exports both :results output
! declare pointer
integer, pointer :: p
! declare targets and assign values
integer, target :: a = 1, b = 2

p => a ! Now p has same memory address as a
p = 2 ! Modify value at address
print*, a==2 ! a is 2

p => b ! Now p has same memory address as b
p = 1 ! Modify value at address
print*, b==1 ! b is 1

! Is p associated with a target?
print*, associated(p)

! Is p associated with the target a?
print*, associated(p, a)

! Point to nowhere
nullify(p)
#+end_src

** Arrays
The length of an array can be fixed or dynamic. The index of an array starts at 1 by default, but any index range can be specified.
*** Fixed-length arrays
Here's a one-dimensional array example.
#+begin_src fortran -n
real :: a(5)

! you can work with each component individually
! set the first component to 1
a(1) = 1.0

! or you can work with the whole array
! set the whole array to 2
a = 2.0

! or you can with slices of the array
! set first three components to 3
a(1:3) = 3.0
#+end_src

And, here's a two-dimensional array example.
#+begin_src fortran -n
real :: a(5,5)

! you can work with each component individually
! set upper left component to 1
a(1,1) = 1.0

! or you can work with the whole array
! set the whole array to 2
a = 2.0

! or you can with slices of the array
! set upper left 2x2 submatrix to 3
a(1:2, 1:2) = 3.0
#+end_src

Fortran includes intrinsic functions to operate on an array =a= such as
- =size(a)=: number of elements of =a=
- =minval(a)=: minimum value of =a=
- =maxval(a)=: maximum value of =a=
- =sum(a)=: sum of elements in =a=
- =product(a)=: product of elements in =a=
See the =gfortran= documentation for more.

*** Dynamic length arrays
Dynamic arrays are declared with the =allocatable= modifier. Before storing values in such an array, you must =allocate= memory for the array. After you are finished the array, you ought to =deallocate= the memory that it occupies.

Here's a one-dimensional example.
#+begin_src fortran -n -r
! declare a one-dim. dynamic length array
real, allocatable :: a(:)

! allocate memory for a
allocate(a(5))

! now you can treat a like a normal array
a(1) = 1.0
! etc...

! deallocate memory occupied by a
deallocate(a)

! we can change the size and index range of a
allocate(a(0:10))

a(0) = 1.0
! etc...

deallocate(a) (ref:d)
#+end_src

Without the last =dellaocate= statement on line [[(d)]] the code above is valid, but the memory that is allocated for =a= will not be freed. That memory then cannot be allocated to other resources.

Here's a two-dimensional example.
#+begin_src fortran -n -r
! declare a one-dim. dynamic length array
real, allocatable :: a(:,:)

! allocate memory for a
allocate(a(5,5))

! now you can treat a like a normal array
a(1,1) = 1.0
! etc...

! deallocate memory occupied by a
deallocate(a)

! we can change the size and index range of a
allocate(a(0:10,0:10))

a(0,0) = 1.0
! etc...

deallocate(a)
#+end_src

* Control structures
** Conditionals
*** Example: =if= / =else= and random number generation
Execution of two blocks of code can be controlled with mutually exclusive logic using the =if= / =else= construct. The following code generates a random number between 0 and 1, then prints the number and whether or not the number is greater than 0.5

#+begin_src fortran -n :exports both :results output
real :: num

! seed random number generator
call srand(789)

! rand() returns a random number between 0 and 1
num = rand()

print*, 'num: ', num

if (num < 0.5) then
   print*, 'num is less than 0.5'
else
   print*, 'num is greater then 0.5'
end if

! do it again
num = rand()

print*, 'num: ', num

if (num < 0.5) then
   print*, 'num is less than 0.5'
else
   print*, 'num is greater then 0.5'
end if
#+end_src

#+RESULTS[13675e49eb075ab2495d1e40c7af7bafd17418d0]:
: num:    6.17480278E-03
: num is less than 0.5
: num:   0.783314705    
: num is greater then 0.5

Since the random number generator was seeded with a literal integer, the above code will produce the /same/ output each time it is run.

An =else= block is optional and can be omitted to form an =if= construct in which a block of code executes if a logical expression evaluates to =.true.=.

*** Example: =if= / =else if= / =else=
Execution of three or more blocks of code with mutually exclusive logic can be controlled using the =if= / =else if= / =else= construct. The following code generates a random number between 0 and 1, then prints the number and which quarter of the interval $[0,1]$ that the number is in.

#+begin_src fortran -n -r :exports both :results output
real :: num

! seed random number generator with current time
call srand(time())

! rand() returns a random number between 0 and 1
num = rand()

print*, 'num:', num

if (num > 0.75) then
   print*, 'num is between 0.75 and 1'
else if (num > 0.5) then
   print*, 'num is between 0.5 and 0.75'
else if (num > 0.25) then
   print*, 'num is between 0.25 and 0.5'
else
   print*, 'num is between 0 and 0.25'
end if
#+end_src

#+RESULTS[487c234210bd37d6d1b91cbc44cf625615843b7b]:
: num:  0.693089724    
: num is between 0.5 and 0.75

Since the random number generator was seeded with the current time, the above code will produce a /different/ output each time it is run.

** Loops
*** The =do= loop
A =do= loop iterates a block of code over a range of integers. It takes two =integer= arguments specifying the minimum and maximum (inclusive) of the range and takes an optional third =integer= argument specifying the iteration stride in the form =do i=min,max,stride=. If omitted, the stride is 1.

The following code assigns a value to each component of an array then prints it.

#+begin_src fortran -n :exports both :results output
integer :: max = 10, i
real, allocatable :: x(:)

allocate(x(0:max))

do i = 0,max
   ! assign to each array component
   x(i) = i / real(max)

   ! print current component
   print "('x(', i0, ') = ', f3.1)", i, x(i)
end do

deallocate(x)
#+end_src

#+RESULTS[7206fde40ebad375a7845fa70c041c34fbb7f2c0]:
#+begin_example
x(0) = 0.0
x(1) = 0.1
x(2) = 0.2
x(3) = 0.3
x(4) = 0.4
x(5) = 0.5
x(6) = 0.6
x(7) = 0.7
x(8) = 0.8
x(9) = 0.9
x(10) = 1.0
#+end_example

An /implicit/ =do loop= can be used for formulaic array assignments. The following code creates the same array as the last example.

#+begin_src fortran :export code
integer :: max = 10
real, allocatable :: x(:)

allocate(x(0:max))

! implicit do loop for formulaic array assignment
x = [(i / real(max), i=0, max)]

deallocate(x)
#+end_src

*** Example: row-major matrix

The following code stores matrix data in a one-dimensional array named =matrix= in =row-major= order. This means the first =n_cols= elements of the array will contain the first row of the matrix, the next =n_cols= of the array will contain the second row of the matrix, etc.

#+begin_src fortran -n :exports both :results output
integer :: n_rows = 4, n_cols = 3
real, allocatable :: matrix(:)
! temporary indices
integer :: i,j,k

! row-major matrix array
allocate(matrix(1:n_rows*n_cols))

! assign 0 to all elements of matrix
matrix = 0.0

do i = 1,n_rows
   do j = 1,n_cols
      ! convert (i,j) matrix index to "flat" row-major index
      k = (i-1)*n_cols + j

      ! assign 1 to the diagonal
      ! 2 to the off-diagonal
      if (i==j) then
         matrix(k) = 1.0
      else if ((i==j-1).or.(i==j+1)) then
         matrix(k) = 2.0
      end if
   end do
end do

! print matrix components
do i = 1,n_rows
   print "(2(f3.1,', '), f3.1)", matrix(1+(i-1)*n_cols:i*n_cols)
end do

deallocate(matrix)
#+end_src

#+RESULTS[41c26f0f73c7120d07d5ab121287a34124c3d767]:
: 1.0, 2.0, 0.0
: 2.0, 1.0, 2.0
: 0.0, 2.0, 1.0
: 0.0, 0.0, 2.0

*** The =do while= loop
A =do while= loop iterates while a logical condition evaluates to =.true.=.

**** Example: truncated sum
The following code approximates the geometric series
\begin{equation*}
\sum_{n=1}^{\infty}\left(\frac12\right)^n=1.
\end{equation*}
The =do while= loop exits when the absolute error
\begin{equation*}
E=1-\sum_{n=1}^{\infty}\left(\frac12\right)^n
\end{equation*}
is less than a specified tolerance =tol=.

#+begin_src fortran -n :exports both :results output
real :: sum = 0.0, base = 0.5, tol = 1e-4
real :: pow = 0.5
integer :: iter = 1

do while(1-sum >= tol)
   ! add pow to sum
   sum = sum+pow
   ! update pow by one power of base
   pow = pow*base

   print "('Iter: ', i3, ', Sum: ', f0.5, ', Abs Err: ', f0.5)", iter, sum, 1-sum
   
   ! update iter by 1
   iter = iter+1
end do
#+end_src

#+RESULTS[4ab00e990de5c40405f40a8d40e41fd49fab7066]:
#+begin_example
Iter:  1, Sum: .50000, Abs Err: .50000
Iter:  2, Sum: .75000, Abs Err: .25000
Iter:  3, Sum: .87500, Abs Err: .12500
Iter:  4, Sum: .93750, Abs Err: .06250
Iter:  5, Sum: .96875, Abs Err: .03125
Iter:  6, Sum: .98438, Abs Err: .01562
Iter:  7, Sum: .99219, Abs Err: .00781
Iter:  8, Sum: .99609, Abs Err: .00391
Iter:  9, Sum: .99805, Abs Err: .00195
Iter: 10, Sum: .99902, Abs Err: .00098
Iter: 11, Sum: .99951, Abs Err: .00049
Iter: 12, Sum: .99976, Abs Err: .00024
Iter: 13, Sum: .99988, Abs Err: .00012
Iter: 14, Sum: .99994, Abs Err: .00006
#+end_example

**** Example: estimating machine epsilon

#+begin_src fortran -n :exports both :results output
double precision :: eps
integer, parameter :: dp = kind(eps)
integer :: count = 1

eps = 1.0_dp
do while (1.0_dp + eps*0.5 > 1.0_dp)
   eps = eps*0.5
   count = count+1
end do

print*, eps
print*, epsilon(eps)
print*, count
print*, digits(eps)
#+end_src

#+RESULTS[dcaeab340d8770cf1159ef94ec3cb9a90d7c6173]:
: 2.2204460492503131E-016   2.2204460492503131E-016
:        53          53

*** Example: =exit= keyword
The =exit= keyword is used to stop execution of code within the current scope. The following code finds the /hailstone sequence/ of \(a_1=6\) defined recursively by
\begin{equation*}
a_{n+1} =
\begin{cases}
a_n/2 & \text{if } a_n \text{ is even}\\
3a_n+1 & \text{ if } a_n \text{ is odd} 
\end{cases}
\end{equation*}
for \(n\geq1\). It is an open conjecture that the hailstone sequence of any initial value \(a_1\) converges to the periodic sequence \(4, 2, 1, 4, 2, 1\ldots\). Luckily, it does for \(a_1=6\) and the following =do= loop exits.

#+begin_src fortran -n :exports both :results output
integer :: a = 6, count = 1

! infinite loop
do
   ! if a is even, divide by 2
   ! otherwise multiply by 3 and add 1
   if (mod(a,2)==0) then
      a = a/2
   else
      a = 3*a+1
   end if

   ! if a is 4, exit infinite loop
   if (a==4) then
      exit
   end if

   ! print count and a
   print "('count: ', i2, ', a: ', i2)", count, a

   ! increment count
   count = count + 1
end do
#+end_src

#+RESULTS[613047b57264c89ba471cfa6803babdc9f7f47d2]:
: count:  1, a:  3
: count:  2, a: 10
: count:  3, a:  5
: count:  4, a: 16
: count:  5, a:  8

* Input/Output
** Command line arguments
Arguments can be passed to a program from the command line using =get_command_argument=. The first argument received by =get_command_argument= is the program executable file name and the remaining arguments are passed by the user. The following program accepts any number of arguments, each at most 32 characters, and prints them.

#+name: command_line_arguments
#+begin_src fortran -n :tangle ./command_line_arguments/main.f90
program main
  implicit none

  character(32) :: arg
  integer :: n_arg = 0

  do
     ! get next command line argument
     call get_command_argument(n_arg, arg)

     ! if it is empty, exit
     if (len_trim(arg) == 0) exit

     ! print argument to screen
     print"('argument ', i0, ': ', a)", n_arg, trim(arg)

     ! increment count
     n_arg = n_arg+1
  end do

  ! print total number of arguments
  print "('number of arguments: ', i0)", n_arg

end program main
#+end_src

#+begin_src sh :exports none :dir ./command_line_arguments
gfortran main.f90
#+end_src

After compiling to =a.out=, you can pass arguments in the executing command.

#+begin_src sh :exports both :results output :dir ./command_line_arguments
./a.out 1 2 34
#+end_src

#+RESULTS[62b2c39a3227cfd15861809a5e48b5e3774e5e87]:
: argument 0: ./a.out
: argument 1: 1
: argument 2: 2
: argument 3: 34
: number of arguments: 4

** File input/output
*** Reading data from file

The contents of a data file can be read into an array using =read=. Suppose you have a file =./data/array.txt= that contains two columns of data

: 1 1.23
: 2 2.34
: 3 3.45
: 4 4.56
: 5 5.67

This file can be opened with the =open= command. The required first argument of =open= is an =integer= that specifies a /file unit/ for =array.txt=. Choose any number that is not in use. The unit numbers =0=, =5=, and =6= are reserved for system files and should not be used accidentally. Data are read in *row-major* format, i.e. across the first row, then across the second row, etc.

The following code reads the contents of =./data/array.txt= into an array called =array=.

#+begin_src fortran -n
! declare array
real :: array(5,2)
integer :: row

! open file and assign file unit 10
open (10, file='./data/array.txt', action='read')

! read data from file unit 10 into array
do row = 1,5
   read(10,*) array(row,:)
end do

! close file
close(10)
#+end_src

*** Writing data to file

Data can be written to a file with the =write= command.

#+begin_src fortran -n
real :: x
integer :: i, max = 5

! open file, specify unit 10, overwrite if exists
open(10, file='./data/sine.txt', action='write', status='replace')

do i = 0,max
   x = i / real(max)

   ! write to file unit 10
   write(10,*) x, sin(x)
end do
#+end_src

This produces a file =sine.txt= in the directory =data= containing

:   0.00000000       0.00000000    
:  0.200000003      0.198669329    
:  0.400000006      0.389418334    
:  0.600000024      0.564642489    
:  0.800000012      0.717356086    
:   1.00000000      0.841470957    


** Formatted input/output
The format of a =print=, =read=, or =write= statement can be specified with a =character= string. A format character string replaces the =*= symbol in =print*= and the second =*= symbol in =read(*,*)= or =write(*,*)=. A format string is a list of literal character strings or character descriptors from
- =a=: character string
- =iW=: integer
- =fW.D=: float point 
- =esW.DeE=: scientific notation
- =Wx=: space
where =W=, =D=, and =E= should be replaced by numbers specifying width, number of digits, or number  of exponent digits, resp. The width of a formatted integer or float defaults to the width of the number when =W= is =0=.

#+begin_src fortran -n :exports both :results output
character(32) :: fmt, a = 'word' 
integer :: b = 1
real :: c = 2.0, d = 3.0

! character string and 4 space-delimited values
print "('four values: ', a, 1x i0, 1x f0.1, 1x, es6.1e1)", trim(a), b, c, d

! character string and 2 space-delimited values
fmt = '(a, 2(f0.1, 1x))'
print fmt, 'two values: ', c, d
#+end_src

#+RESULTS[12f83e2b7b1136a7e36d7b049b73fcde8eda8ff4]:
: four values: word 1 2.0 3.0E+0
: two values: 2.0 3.0

* Functions
** Writing a function
Functions are defined after the =contains= keyword in a =module= or =program=. The definition of a function starts with the name of the function followed by a list of arguments and return variable. The data types of the arguments and return variable are defined within the =function= body.

*** Example: =linspace=: generating a set of equally-space points

The following program defines a function =linspace= that returns a set of equidistant points on an interval. The main function makes a call to the function.

#+begin_src fortran -n :exports both :results output
program main
  implicit none

  real :: xs(10)

  ! call function linspace to set values in xs
  xs = linspace(0.0, 1.0, 10)

  ! print returned value of xs
  print "(10(f0.1, 1x))" , xs

contains

  ! linspace: return a set of equidistant points on an interval
  ! min: minimum value of interval
  ! max: maximum value of interval
  ! n_points: number of points in returned set
  ! xs: set of points
  function linspace(min, max, n_points) result(xs)
    real :: min, max, dx
    integer :: n_points
    integer :: i
    real :: xs(n_points)

    ! calculate width of subintervals
    dx = (max-min) / real(n_points-1)

    ! fill xs with points
    do i = 1,n_points
       xs(i) = min + (i-1)*dx
    end do

  end function linspace

end program main
#+end_src

#+RESULTS[2f414e387f7f8b99f2dc9e98a02dc427b7af34a0]:
: .0 .1 .2 .3 .4 .6 .7 .8 .9 1.0

** Interfaces
A function can be passed as an argument to another function if there is an =interface= to instruct the receiving function how to use the passed function. An =interface= to a function is essentially the function itself with only declarations and without implementation.

*** Example: Newton's method for rootfinding
Newton's method for finding the root of a function $f:\mathbb{R}\rightarrow\mathbb{R}$ refines an initial guess $x_0$ according to the iteration rule
\begin{equation*}
x_{n}=x_n-\frac{f(x_n)}{f'(x_n)}
\end{equation*}
for $n\geq1$ until $f(x)$ is less than a chosen tolerance or a maximum number of iterations. The following code converges to a root of $f(x)=x^2-2$ from an initial guess $x_0=1$.

#+begin_src fortran -n :exports both :results output
program main
  implicit none

  real :: x

  ! call newton rootfinding function
  x = newton(f, df, 1.0, 1e-6, 1000, .true.)

contains

  ! function f(x) = x^2 - 2
  function f(x) result(y)
    real :: x, y
    y = x*x - 2
  end function f

  ! function df(x) = 2x
  function df(x) result(dy)
    real :: x, dy
    dy = 2*x
  end function df

  ! newton: newtons method for rootfinding
  ! f: function with root
  ! df: derivative of f
  ! x0: initial iterate
  ! tol: absolute tolerance
  ! max_iters: maximum number of iterations
  ! print_iters: boolean to toggle verbosity
  function newton(f, df, x0, tol, max_iters, print_iters) result(x)

    ! interface to function f
    interface
       function f(x) result(y)
         real :: x, y
       end function f
    end interface

    ! interface to function df
    interface
       function df(x) result(dy)
         real :: x, dy
       end function df
    end interface

    real :: x0, tol, x
    integer :: iter, max_iters
    logical :: print_iters

    ! initialize x
    x=x0

    ! while f(x) greater than absolute tolerance
    ! and max number of iterations not exceeded
    do while (abs(f(x))>tol.and.iter<max_iters)
       ! print current x and f(x)
       if (print_iters) print "('f(', f0.7, ') = ', f0.7)", x, f(x)

       ! Newton's update rule
       x = x - f(x)/df(x)

       ! increment number of iterations
       iter = iter + 1
    end do
    ! print last x and f(x)
    if (print_iters) print "('f(', f0.7, ') = ', f0.7)", x, f(x)

  end function newton

end program main
#+end_src

#+RESULTS[3767d56cfea7d6663ee3887561495277dadfafaf]:
: f(1.0000000) = -1.0000000
: f(1.5000000) = .2500000
: f(1.4166666) = .0069444
: f(1.4142157) = .0000060
: f(1.4142135) = -.0000001

*** Example: The midpoint rule for definite integrals

#+begin_src fortran -n :exports both :results output
program main
  implicit none

  real, parameter :: E = exp(1.)
  integer :: n
  real :: integral

  do n = 2,20,2
     print "('n: ', i0, ' M_n: ', f0.6)", n, midpoint(f, 1.0, E, n)
  end do

contains

  ! function f(x) = 1/x
  function f(x) result(y)
    real :: x, y
    y = 1.0/x
  end function f

  ! midpoint: midpoint rule for definite integral
  ! f: integrand
  ! a: left endpoint of interval of integration
  ! b: right endpoint of interval of integration
  ! n: number of subintervals
  ! sum: approximate definite integral
  function midpoint(f, a, b, n) result(sum)

    ! interface to f
    interface
       function f(x)
         real :: x, y
       end function f
    end interface

    real :: a, b, min, xi, dx, sum
    integer :: n, i

    ! subinterval increment
    dx = (b-a)/real(n)
    ! minimum to increment from
    min = a - dx/2.0

    ! midpoint rule
    do i = 1,n
       xi = min + i*dx
       sum = sum + f(xi)
    end do
    sum = sum*dx

  end function midpoint

end program main

#+end_src

* Subroutines
Whereas a =function= does not return changes to its arguments and returns at most one value, a =subroutine= can be used to return changes to multiple arguments.
** Writing a subroutine
 A =subroutine= is defined after the =contains= keyword in a program or module. The definition of a subroutine begins with the name of the subroutine and list of arguments. Arguments are defined within the =subroutine= body with one of the following intents
- =intent(in)=: changes to the argument are not returned
- =intent(inout)=: changes to the argument are returned
- =intent(out)=: the initial value of the argument is ignored and changes to the argument are returned.

#+html: </div>
