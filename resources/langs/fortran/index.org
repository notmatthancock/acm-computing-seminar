#+title: ACM Computing Seminar Fortran Guide
#+author: Joseph P. McKenna
#+email: joepatmckenna@gmail.com
#+property: header-args :mkdirp yes :cache yes
#+property: header-args:fortran :exports code :results output
#+property: header-args:sh :exports both
#+startup: latexpreview
#+options: html-postamble:nil
#+html_head: <link rel="stylesheet" type="text/css" href="../css/main.css">
#+html_head: <link rel="stylesheet" type="text/css" href="../css/fortran.css">
#+html_head: <script src="../js/main.js"></script>
#+html: <div id="main">
#+html: <a href="../../../" id="home-link">ACM Computing Seminar Home</a>

:snippets:
# * ${n \choose k}$
# #+begin_src fortran :tangle choose/main.f90
#   program main
#     implicit none
#     print*, choose(4,0), choose(4,1), &
#          choose(4,2), choose(4,3), choose(4,4)
#   contains
#     function choose(n,k) result(c)
#       integer, intent(in) :: n, k
#       integer :: c, i
#       c = 1
#       do i = 1, min(k,n-k)
#          c = c * (n-i+1) / i
#       end do
#     end function choose
#   end program main
# #+end_src

# #+begin_src sh :dir choose
# gfortran main.f90 -o main
# #+end_src

# #+begin_src sh :dir choose
# ./main
# #+end_src

# * Setting precision of variables
# #+begin_src fortran :tangle precision/constants.f90
#   module constants
#     implicit none
#     integer, parameter :: sp = kind(0.), dp = kind(0.d0)
#     integer, parameter :: rp = dp
#   end module constants
# #+end_src

# #+begin_src sh :dir precision
# gfortran -c constants.f90
# #+end_src

# #+begin_src fortran :tangle precision/main.f90
#   program main
#     use constants
#     implicit none
#     real(rp) :: x, y
#     x = 1._rp
#     y = real(1,rp)
#   end program main
# #+end_src

# #+begin_src sh :dir precision
# gfortran main.f90 constants.o -o main
# #+end_src

# #+begin_src sh :dir precision
# ./main
# #+end_src

# #+begin_src make :exports none :tangle precision/makefile
#   FC = gfortran
#   SRC = main.f90
#   EXE = main
#   OBJ = constants.o

#   all: $(EXE)
#   $(EXE): $(OBJ)
#     $(FC) $(OBJ) $(SRC) -o $(EXE) 
#   %.o: %.f90
#     $(FC) -c $< -o $@
#   clean:
#     $(RM) *.o $(EXE)
# #+end_src

# * Machine Epsilon
# #+begin_src fortran :tangle epsilon/constants.f90
#   module constants
#     implicit none

#     integer, parameter :: sp = kind(0.), dp = kind(0.d0)
#     integer, parameter :: rp = dp

#     interface machine_epsilon
#        module procedure machine_epsilon_sp, machine_epsilon_dp
#     end interface machine_epsilon

#   contains

#     function machine_epsilon_sp(x) result(e)
#       implicit none
#       real(sp), intent(in) :: x
#       real :: e
#       e = .5
#       do while (1._sp + e > 1._sp)
#          e = .5 * e
#       end do
#     end function machine_epsilon_sp

#     function machine_epsilon_dp(x) result(e)
#       implicit none
#       real(dp), intent(in) :: x
#       real :: e
#       e = .5
#       do while (1._dp + e > 1._dp)
#          e = .5 * e
#       end do
#     end function machine_epsilon_dp

#   end module constants
# #+end_src

# #+begin_src sh :dir epsilon
# gfortran -c constants.f90
# #+end_src

# #+begin_src fortran :tangle epsilon/main.f90
#   program main
#     use constants
#     implicit none
#     print*, machine_epsilon(0._sp), machine_epsilon(0._dp)
#   end program main
# #+end_src

# #+begin_src sh :dir epsilon
# gfortran main.f90 constants.o -o main
# #+end_src
 
# #+begin_src sh :dir epsilon
# ./main
# #+end_src

# #+begin_src make :exports none :tangle epsilon/makefile
#   FC = gfortran
#   SRC = main.f90
#   EXE = main
#   OBJ = constants.o

#   all: $(EXE)
#   $(EXE): $(OBJ)
#     $(FC) $(OBJ) $(SRC) -o $(EXE) 
#   %.o: %.f90
#     $(FC) -c $< -o $@
#   clean:
#     $(RM) *.o $(EXE)
# #+end_src

# #+begin_src fortran :exports both
#   print*, epsilon(0.), epsilon(0.d0)
# #+end_src

# * Rootfinding

# #+begin_src fortran :tangle rootfind/functions.f90
#   module functions
#     implicit none

#   contains

#     function f1(x)
#       real, intent(in) :: x
#       real :: f1
#       f1 = sin(x)
#     end function f1

#     function df1dx(x)
#       real, intent(in) :: x
#       real :: df1dx
#       df1dx = cos(x)
#     end function df1dx

#   end module functions
# #+end_src

# #+begin_src sh :dir rootfind
# gfortran -c functions.f90
# #+end_src

# #+begin_src fortran :tangle rootfind/rootfind.f90
#   module rootfind
#     implicit none

#     interface
#        function fun(x)
#          real, intent(in) :: x
#          real :: fun
#        end function fun
#     end interface

#   contains

#     function newton(f,dfdx,x0,tol,maxstep) result(xn)
#       procedure(fun), pointer :: f, dfdx
#       real, intent(in) :: x0, tol
#       integer, intent(in) :: maxstep
#       real :: xn
#       integer :: n = 0

#       xn = x0
#       do while (abs(f(xn))>tol .and. n<maxstep)
#          xn = xn - f(xn)/dfdx(xn)
#          n = n + 1
#       end do
#     end function newton

#   end module rootfind
# #+end_src

# #+begin_src sh :dir rootfind
# gfortran -c rootfind.f90
# #+end_src

# #+begin_src fortran :tangle rootfind/main.f90
#   program main
#   	use functions
#     use rootfind
#     implicit none

#     procedure(fun), pointer :: f, dfdx
#     real :: x = 1., tol = 1e-5
#     integer :: maxstep = 100
#     f => f1
#     dfdx => df1dx
#     print*, newton(f,dfdx,x,tol,maxstep)

#   end program main
# #+end_src

# #+begin_src sh :dir rootfind
# gfortran main.f90 functions.o rootfind.o -o main
# #+end_src

# #+begin_src make :exports none :tangle rootfind/makefile
#   FC = gfortran
#   SRC = main.f90
#   EXE = main
#   OBJ = functions.o rootfind.o

#   all: $(EXE)
#   $(EXE): $(OBJ)
#     $(FC) $(OBJ) $(SRC) -o $(EXE) 
#   %.o: %.f90
#     $(FC) -c $< -o $@
#   clean:
#     $(RM) *.o $(EXE)
# #+end_src

# #+begin_src sh :dir rootfind
# ./main
# #+end_src

# * Quadrature

# #+begin_src fortran :tangle quadrature/functions.f90
#   module functions
#     implicit none

#   contains

#     function f1(x)
#       real, intent(in) :: x
#       real :: f1
#       f1 = x
#     end function f1

#   end module functions
# #+end_src

# #+begin_src sh :dir quadrature
#   gfortran -c functions.f90
# #+end_src

# #+begin_src fortran :tangle quadrature/quadrature.f90
#   module quadrature
#     implicit none

#   contains

#     function midpoint_rule(f,a,b,n) result(I)
#       interface
#          function f(x)
#            real, intent(in) :: x
#            real :: f
#          end function f
#       end interface
#       real :: a, b
#       integer :: n, j
#       real :: I, dx

#       dx = (b-a)/real(n)
#       I = 0
#       do j = 0,n-1
#          I = I + f(a + (j+.5)*dx)
#       end do
#       I = dx*I
#     end function midpoint_rule

#   end module quadrature
# #+end_src

# #+begin_src sh :dir quadrature
#   gfortran -c quadrature.f90
# #+end_src

# #+begin_src fortran :tangle quadrature/main.f90
#   program main
#     use functions
#     use quadrature
#     implicit none

#     real :: a = 0, b = 1
#     integer :: n = 5
#     print*, midpoint_rule(f1,a,b,n)

#   end program main
# #+end_src

# #+begin_src sh :dir quadrature
#   gfortran main.f90 functions.o quadrature.o -o main
# #+end_src

# #+begin_src make :exports none :tangle quadrature/makefile
#   FC = gfortran
#   SRC = main.f90
#   EXE = main
#   OBJ = functions.o quadrature.o

#   all: $(EXE)
#   $(EXE): $(OBJ)
#     $(FC) $(OBJ) $(SRC) -o $(EXE) 
#   %.o: %.f90
#     $(FC) -c $< -o $@
#   clean:
#     $(RM) *.o $(EXE)
# #+end_src

# #+begin_src sh :dir quadrature
#   ./main
# #+end_src

# * Matrix multiplication
# #+begin_src fortran :exports both :tangle matmul/main.f90
#   program main
#     implicit none

#     real :: A(4,4), B(4,4)
#     A=1; B=2

#     print*, matrix_multiply(A,B)

#   contains

#     function matrix_multiply(A,B) result(C)
#       implicit none
#       real :: A(4,4), B(4,4), C(4,4)
#       integer :: i,j,k

#       C = 0
#       do i=1,4
#          do j=1,4
#             do k=1,4
#                C(i,j) = C(i,j) + A(i,k)*B(k,j)
#             end do
#          end do
#       end do

#       end function matrix_multiply

#   end program main
# #+end_src
# * $\sum_{n=0}^{\infty}\frac1{n!}$
# #+begin_src fortran :exports both :tangle series/main.f90
#   program main
#     implicit none
#     integer :: n = 0, nf = 1
#     real :: s = 0
#     do while (1./real(nf) > 0)
#        s = s + 1./real(nf)
#        n = n + 1
#        nf = nf * n
#     end do
#     print*, s, exp(1.)-s
#   end program main
# #+end_src
:end:

* Introduction
This guide is intended to quickly get you up-and-running in scientific computing with Fortran. There is a companion [[../cpp/index.html][C++ guide]] that parallels the content of this guide. 
** About the language
Fortran was created in the 1950s for mathematical *FOR*-mula *TRAN*-slation, and has since gone through a number of revisions (FORTRAN 66, 77, and Fortran 90, 95, 2003, 2008, 2015). The language standards are put forth by the Fortran standards committee [[http://www.j3-fortran.org][J3]] in a document (ISO 1539-1:2010) available for purchase. The syntax and intrinsic capabilities of the language make it especially suited for scientific computing. Like C/C++, Fortran is a *statically-typed* and *compiled* language. You must declare the *type*, i.e. integer, real number, etc. of variables in programs you write. Your programs will be translated from human-readable /source code/ into a machine-executable file by software called a *compiler*. 

* Getting started
The software that you need to get started comes prepackaged and ready to download on most Linux distributions. There are a few options for emulating a Linux environment in Windows or Mac OS, such as a virtual machine (VirtualBox) or package manager (MinGW or Cygwin on Windows and Brew on Mac OS).
** Text editor
You will write the source code of your programs using a text editor. There are many options that have features designed for programming such as syntax highlighting and auto-completion. If you are an impossible-to-please perfectionist, you might want to check out [[https://www.gnu.org/s/emacs/][Emacs]]. If you are easier to please, you might want to check out [[https://www.sublimetext.com/][Sublime Text]].
** Compiler
To translate your source code into an executable, you will need a Fortran compiler. A free option is *gfortran*, part of the GNU compiler collection (gcc). The features of the Fortran language that are supported by the compiler are specified in the compiler documentation. This is your most complete reference for the intrinsic capabilities of Fortran that your programs can use. At the time of this writing, =gfortran= completely supports Fortran 95 and partially supports more recent standards.
** Writing a program
*** Hello world
Let's write a tiny program that prints "hello world" to the terminal screen in =hello.f90=

#+begin_src fortran -n :tangle hello/hello.f90
program main
  print*, 'hello world'
end program main
#+end_src

To compile the program, execute the following command in the same directory as =hello.f90=

#+begin_src sh :dir hello
gfortran hello.f90
#+end_src

This produces an executable file named =a.out= by default (On Windows, this is probably named =a.exe= by default). To run, execute the file.

#+begin_src sh :dir hello
./a.out
#+end_src

We could have specified a different name for the executable file during compilation with the =-o= option of =gfortran=.

#+begin_src sh :dir hello
gfortran hello.f90 -o my_executable_file
#+end_src

On Windows, you should append the =.exe= extension to =my_executable_file=.

*** Template
Now let's write an empty template for future projects. This section may seem overly complex at first read, but it is best to adopt some form of organization when you are just getting started. Our source code template will consist of two files in the same directory ([[./template/]]). In the following files, the contents of a line after a =!= symbol is a comment that is ignored by the compiler. One file =header.f90= is a *module* that defines things to be used in the main program.

#+begin_src fortran -n -r :tangle template/header.f90
module header
  implicit none (ref:in1)
  ! variable declarations and assignments
contains
  ! function and subroutine definitions
end module header
#+end_src

This file is compiled into an *object file* with the =-c= option of =gfortran=

#+begin_src sh :dir template
gfortran -c header.f90
#+end_src

This outputs the object file named =header.o= by default that can be /linked/ to the main program. A separate file =main.f90= contains the main program.

#+begin_src fortran -n -r :tangle template/main.f90
program main
  use header (ref:u)
  implicit none (ref:in2)
  ! variable declarations and assignments
  ! function and subroutine calls
contains
  ! function and subroutine definitions
end program main
#+end_src

On line [[(u)]] of =main.f90=, we instruct the main program to use things defined in =header.f90=, so we must link the object file =header.o= when compiling =main.f90=.

#+begin_src sh :dir template
gfortran main.f90 header.o -o main
#+end_src

To run the program, execute the output file =main= in the same directory.

#+begin_src sh :dir template
./main
#+end_src

As you get more experience, you will find it very cumbersome to repeatedly execute =gfortran= commands with every modification to your code. Using the =make= command-line utility is a way around this. You can specify all the compilation commands for your project in a file named =makefile=. For example, the template above could use the following =makefile=.

#+begin_src make -n -r :tangle template/makefile
FC = gfortran
SRC = main.f90
EXE = main
OBJ = header.o(ref:obj)

all: $(EXE)
$(EXE): $(OBJ)
	$(FC) $(SRC) $(OBJ) -o $(EXE)
%.o: %.f90
	$(FC) -c $< -o $@
#+end_src

Then, to recompile both =header.f90= and =main.f90= after modifying either file, execute

#+begin_src sh :exports code :dir template
make
#+end_src

in the same directory. The first four lines of =makefile= assign variables for the compiler command, file name of the main program, file name of the executable to be created, and file name(s) of linked object file(s), respectively. If you wrote a second module in a separate file =my_second_header.f90= that you wanted to =use= in =main.f90=, you would modify line [[(obj)]] of =makefile= to =OBJ = header.o my_second_header.o=. The remaining lines contain instructions for compilation.

** Exercises
1. Compile and run =hello.f90=.
2. Execute =man gfortran= in any directory to bring up the manual for =gfortran=. Read the description and skim through the options. Do the same for =make=.

* Data types
We will use the =implicit none= keyword at the beginning of each code block as in line [[(in1)]] of =header.f90= and line [[(in2)]] of =main.f90= in Section [[Template]]. The role of this keyword is to suppress some implicit rules that Fortran has for undeclared variables, and by including it we force ourselves to declare each variable that we use. This means our code will be slightly longer than necessary but it will facilitate debugging when our program fails to compile. Without the =implicit none= keyword, an undeclared variable with a name such as =i= is assumed to be an integer data type whereas an undeclared variable with a name such as =x= is assumed to be a real data type.

In addition to the most common data types presented below, Fortran has a =complex= data type and support for user-defined data types.

** The =logical= type
A variable of the =logical= type can have values =.true.= or =.false.=. Logical expressions can be computed with a few operators 

#+begin_src fortran -n 
logical :: a,b,c
a = .true.
b = .false.

! '.not.' is the logical negation operator
c = .not.a ! c is false

! '.and,' is the logical and operator
c = a.and.b ! c is false

! '.or.' is the logical or operator
c = a.or.b ! c is true

! '==' is the test for equality
c = (1 == 2) ! c is false

! '/=' is test for inequality
c = (1 /= 2) ! c is true
#+end_src

#+RESULTS[aafe5eb2ce157c09b1e0faff1d07c64e2138c81b]:

Other logical operators include
- =<= or =.lt.=: less than
- =<== or =.le.=: less than or equal
- =>= or =.gt.=: greater than
- =>== or =.ge.=: greater than or equal

Logical expressions are often used in [[Control structures][control structures]].

** The =integer= type
An =integer= data type can hold integer values. If a real value is assigned to an =integer= type, the decimal portion is truncated.

#+begin_src fortran -n
integer :: a = 6, b = 7 ! initialize a and b to 6 and 7, resp
integer :: c

c = a / b ! c is 0
c = b / a ! c is 1
c = mod(b,a) ! c is 1, 'mod' is the modulo operator
c = b - a ! c is -1
c = a > b ! c is 0 (logical gets cast to integer)
c = a < b ! c is 1 (logical gets cast to integer)
#+end_src

** Floating point types
The two floating point data types =real= and =double precision= correspond to [[https://en.wikipedia.org/wiki/IEEE_floating_point][IEEE 32- and 64-bit floating point data types]].

#+begin_src fortran -n :exports both :results output
real :: a ! declare a single precision float
double precision :: b ! declare a double precision float

! Print the max value of a real type
print*, huge(a)

! Print the max value of a double precision type
print*, huge(b)

! Print machine epsilon for the single precision floating point system
print*, epsilon(a)

! Print machine epsilon for the double precision floating point system
print*, epsilon(b)
#+end_src

** The =character= type
A =character= data type is used to store letters. The maximum length of a character data type is specified with a positive =integer= argument at declaration.

#+begin_src fortran -n :exports both :results output
! declare a character variable s at most 32 characters
character(32) :: s

! assign value to s
s = 'file_name'

! trim trailing spaces from s and
! append a character literal '.dat'
print*, trim(s) // '.dat'
#+end_src

#+RESULTS[c3a6a5819483cbe582a8e546b85faea5057dd928]:
: file_name.dat

** Casting
An integer can be cast to a real number or vice versa.

#+begin_src fortran -n
integer :: a = 1, b
real :: c, PI = 3.14159

b = int(PI) ! b is 3

c = a/b ! c is 0

c = a/real(b) ! c is .3333...
#+end_src

** The =parameter= modifier
To protect a variable from reassignment, you can use the =parameter= modifier. If this modifier is used, the corresponding variable must be assigned a value at declaration, and that value cannot be reassigned. The following code is not valid because of the reassignment =PI = 3=.

#+begin_src fortran -n
! declare constant
real, parameter :: PI = 2.*asin(1.) ! 'asin' is arcine function
! attempt to reassign value
PI = 3
#+end_src

The compiler produces an error like =Error: Named constant ‘pi’ in variable definition context (assignment)=.

** Setting the precision
Each data type is assigned an integer by the Fortran =kind= function. You can write a program in a chosen precision with the =kind= of the precision stored in a variable =rp=. Then, if you want to change the precision, you could change the value of =rp= and recompile. The precision of a variable can be set at declaration and a variable or constant can be cast to a specified precision, each by supplying an extra argument.

#+begin_src fortran -n
real :: r ! declare a real, single precision by default
double precision :: d ! declare a double precision
integer, parameter :: sp = kind(r), dp = kind(d) ! store kinds of r and d
integer, parameter :: rp = sp ! set current kind

! declare real b in double precision
real(dp) :: b

! declare real a with precision kind rp
real(rp) :: a

! cast 1 to real with precision kind rp and assign to a
a = 1.0_rp

! cast b to real with precision kind rp and assign to a
a = real(b,rp)
#+end_src

** Pointers
Pointers have the same meaning in Fortran as in C++. A pointer is a variable that holds the *memory address* for a variable of a specific type. The implementation of pointers is qualitatively different in Fortran than in C++. In Fortran, the user cannot view the memory address that a pointer stores. A pointer variable is declared with the =pointer= modifier, and a variable that it points to is declared with the =target= modifier. The types of a =pointer= and its =target= must match.

#+begin_src fortran -n :exports both :results output
! declare pointer
integer, pointer :: p
! declare targets and assign values
integer, target :: a = 1, b = 2

p => a ! Now p has same memory address as a
p = 2 ! Modify value at address
print*, a==2 ! a is 2

p => b ! Now p has same memory address as b
p = 1 ! Modify value at address
print*, b==1 ! b is 1

! Is p associated with a target?
print*, associated(p)

! Is p associated with the target a?
print*, associated(p, a)

! Point to nowhere
nullify(p)
#+end_src

** Arrays
The length of an array can be fixed or dynamic. The index of an array starts at 1 by default, but any index range can be specified.
*** Fixed-length arrays
Here's a one-dimensional array example.
#+begin_src fortran -n
real :: a(5)

a(1) = 1.0
! etc
#+end_src

And, here's a two-dimensional array example.
#+begin_src fortran -n
real :: a(5,5)

a(1,1) = 1.0
! etc
#+end_src

*** Dynamic length arrays
Dynamic arrays are declared with the =allocatable= modifier. Before storing values in such an array, you must =allocate= memory for the array. After you are finished the array, you ought to =deallocate= the memory that it occupies.

Here's a one-dimensional example.
#+begin_src fortran -n -r
! declare a one-dim. dynamic length array
real, allocatable :: a(:)

! allocate memory for a
allocate(a(5))

! now you can treat a like a normal array
a(1) = 1.0
! etc...

! deallocate memory occupied by a
deallocate(a)

! we can change the size and index range of a
allocate(a(0:9))

a(0) = 1.0
! etc...

deallocate(a) (ref:d)
#+end_src

Without the last =dellaocate= statement on line [[(d)]] the code above is valid, but the memory that is allocated for =a= will not be freed. That memory then cannot be allocated to other resources.

Here's a two-dimensional example.
#+begin_src fortran -n -r
! declare a one-dim. dynamic length array
real, allocatable :: a(:,:)

! allocate memory for a
allocate(a(5,2))

! now you can treat a like a normal array
a(1,1) = 1.0
! etc...

! deallocate memory occupied by a
deallocate(a)

! we can change the size and index range of a
allocate(a(0:9,0:1))

a(0,0) = 1.0
! etc...

deallocate(a)
#+end_src

* Control structures
** Conditionals
*** Example: =if= / =else= and random number generation
You can control execution of two blocks of code with mutually exclusive logic using the =if= / =else= construct. An =else= block is optional and can be omitted to form an =if= construct in which a block of code executes if a logical expression evaluates to =.true.=. The following code generates a random number between 0 and 1, then prints the number and whether or not the number is greater than 0.5

#+begin_src fortran -n :exports both :results output
real :: num

! seed random number generator
call srand(789)

! rand() returns a random number between 0 and 1
num = rand()

print*, 'num: ', num

if (num < 0.5) then
   print*, 'num is less than 0.5'
else
   print*, 'num is greater then 0.5'
end if

! do it again
num = rand()

print*, 'num: ', num

if (num < 0.5) then
   print*, 'num is less than 0.5'
else
   print*, 'num is greater then 0.5'
end if
#+end_src

#+RESULTS[13675e49eb075ab2495d1e40c7af7bafd17418d0]:
: num:    6.17480278E-03
: num is less than 0.5
: num:   0.783314705    
: num is greater then 0.5

Since the random number generator was seeded with a literal integer, the above code will produce the /same/ output each time it is run.

*** Example: =if= / =else if= / =else=

You can control execution of two blocks of code with mutually exclusive logic using the =if=/=else= construct. The following code generates a random number between 0 and 1, then prints the number and the quarter of the interval $[0,1]$ that the number is in.

#+begin_src fortran -n -r :exports both :results output
real :: num

! seed random number generator with current time
call srand(time())

! rand() returns a random number between 0 and 1
num = rand()

print*, 'num:', num

if (num > 0.75) then
   print*, 'num is between 0.75 and 1'
else if (num > 0.5) then
   print*, 'num is between 0.5 and 0.75'
else if (num > 0.25) then
   print*, 'num is between 0.25 and 0.5'
else
   print*, 'num is between 0 and 0.25'
end if
#+end_src

#+RESULTS[487c234210bd37d6d1b91cbc44cf625615843b7b]:
: num:  0.693089724    
: num is between 0.5 and 0.75

Since the random number generator was seeded with the current time, the above code will produce a /different/ output each time it is run.

** Loops
*** The =do= loop
A =do= loop iterates a block of code over a range of integers. It takes two =integer= arguments specifying the minimum and maximum (inclusive) of the range and takes an optional third =integer= argument specifying the iteration stride in the form =do i=min,max,stride=. If omitted, the stride is 1.

The following code assigns a value to each component of an array then prints it.

#+begin_src fortran -n :exports both :results output
integer :: max = 10, i
real, allocatable :: x(:)

allocate(x(0:max))

do i = 0,max
   ! assign to each array component
   x(i) = i / real(max)

   ! print current component
   print "('x(', i0, ') = ', f3.1)", i, x(i)
end do

deallocate(x)
#+end_src

*** Example: row-major matrix

#+begin_src fortran -n :exports both :results output
integer :: n_rows = 4, n_cols = 3
real, allocatable :: matrix(:)
! temporary indices
integer :: i,j,k

! row-major matrix array
allocate(matrix(1:n_rows*n_cols))

! assign 0 to all elements of matrix
matrix = 0.0

do i = 1,n_rows
   do j = 1,n_cols
      ! convert (i,j) matrix index to "flat" row-major index
      k = (i-1)*n_cols + j

      ! assign 1 to the diagonal
      ! 2 to the off-diagonal
      if (i==j) then
         matrix(k) = 1.0
      else if ((i==j-1).or.(i==j+1)) then
         matrix(k) = 2.0
      end if
   end do
end do

! print matrix components
do i = 1,n_rows
   print*, matrix(1+(i-1)*n_cols:i*n_cols)
end do

deallocate(matrix)
#+end_src

*** The =do while= loop
A =do while= loop iterates while a logical condition evaluates to =.true.=.

**** Example: truncated sum
The following code approximates the geometric series
\begin{equation*}
\sum_{n=1}^{\infty}\left(\frac12\right)^n=1.
\end{equation*}
The =do while= loop exits when the absolute error
\begin{equation*}
E=1-\sum_{n=1}^{\infty}\left(\frac12\right)^n
\end{equation*}
is less than a specified tolerance =tol=.

#+begin_src fortran -n :exports both :results output
real :: sum = 0.0, base = 0.5, tol = 1e-4
real :: pow = 0.5
integer :: iter = 1

do while(1-sum >= tol)
   ! add pow to sum
   sum = sum+pow
   ! update pow by one power of base
   pow = pow*base

   print "('Iter: ', i3, ', Sum: ', f0.5, ', Abs Err: ', f0.5)", iter, sum, 1-sum
   
   ! update iter by 1
   iter = iter+1
end do
#+end_src

#+RESULTS[4ab00e990de5c40405f40a8d40e41fd49fab7066]:
#+begin_example
Iter:  1, Sum: .50000, Abs Err: .50000
Iter:  2, Sum: .75000, Abs Err: .25000
Iter:  3, Sum: .87500, Abs Err: .12500
Iter:  4, Sum: .93750, Abs Err: .06250
Iter:  5, Sum: .96875, Abs Err: .03125
Iter:  6, Sum: .98438, Abs Err: .01562
Iter:  7, Sum: .99219, Abs Err: .00781
Iter:  8, Sum: .99609, Abs Err: .00391
Iter:  9, Sum: .99805, Abs Err: .00195
Iter: 10, Sum: .99902, Abs Err: .00098
Iter: 11, Sum: .99951, Abs Err: .00049
Iter: 12, Sum: .99976, Abs Err: .00024
Iter: 13, Sum: .99988, Abs Err: .00012
Iter: 14, Sum: .99994, Abs Err: .00006
#+end_example

**** Example: estimating machine epsilon

#+begin_src fortran -n :exports both :results output
double precision :: eps
integer, parameter :: dp = kind(eps)
integer :: count = 1

eps = 1.0_dp
do while (1.0_dp + eps*0.5 > 1.0_dp)
   eps = eps*0.5
   count = count+1
end do

print*, eps
print*, epsilon(eps)
print*, count
print*, digits(eps)
#+end_src

#+RESULTS[dcaeab340d8770cf1159ef94ec3cb9a90d7c6173]:
: 2.2204460492503131E-016   2.2204460492503131E-016
:        53          53

*** Example: =exit= keyword
The =exit= keyword is used to stop execution of code within the current scope. The following code finds the /hailstone sequence/ of \(a_1=6\) defined recursively by
\begin{equation*}
a_{n+1} =
\begin{cases}
a_n/2 & \text{if } a_n \text{ is even}\\
3a_n+1 & \text{ if } a_n \text{ is odd} 
\end{cases}
\end{equation*}
for \(n\geq1\). It is an open conjecture that the hailstone sequence of any initial value \(a_1\) converges to the periodic sequence \(4, 2, 1, 4, 2, 1\ldots\). Luckily, it does for \(a_1=6\) and the following =do= loop exits.

#+begin_src fortran -n :exports both :results output
integer :: a = 6, count = 1

! infinite loop
do
   ! if a is even, divide by 2
   ! otherwise multiply by 3 and add 1
   if (mod(a,2)==0) then
      a = a/2
   else
      a = 3*a+1
   end if

   ! if a is 4, exit infinite loop
   if (a==4) then
      exit
   end if

   ! print count and a
   print "('count: ', i2, ', a: ', i2)", count, a

   ! increment count
   count = count + 1
end do
#+end_src

#+RESULTS[613047b57264c89ba471cfa6803babdc9f7f47d2]:
: count:  1, a:  3
: count:  2, a: 10
: count:  3, a:  5
: count:  4, a: 16
: count:  5, a:  8

* Input/Output
** Command line arguments
Arguments can be received by the main program from the command line using =get_command_argument=. The first argument received by this command is the executable file name and the remaining arguments are supplied by the user. The following program accepts any number of arguments, each at most 32 characters, and prints them.

#+name: command_line_arguments
#+begin_src fortran -n :tangle ./command_line_arguments/main.f90
program main
  implicit none

  character(32) :: arg
  integer :: n_arg = 0

  do
     ! get next command line argument
     call get_command_argument(n_arg, arg)

     ! if it is empty, exit
     if (len_trim(arg) == 0) exit

     ! print argument to screen
     print"('argument ', i0, ': ', a)", n_arg, trim(arg)

     ! increment count
     n_arg = n_arg+1
  end do

  ! print total number of arguments
  print "('number of arguments: ', i0)", n_arg

end program main
#+end_src

#+begin_src sh :exports none :dir ./command_line_arguments
gfortran main.f90
#+end_src

After compiling to =a.out=, you can pass arguments in the executing command.

#+begin_src sh :exports both :results output :dir ./command_line_arguments
./a.out 1 2 34
#+end_src

#+RESULTS[62b2c39a3227cfd15861809a5e48b5e3774e5e87]:
: argument 0: ./a.out
: argument 1: 1
: argument 2: 2
: argument 3: 34
: number of arguments: 4

** File input/output
*** Reading data from file

The contents of a data file can be read into an array using =read=. Suppose you have a file =./data/array.txt= that contains

: 1 1.23
: 2 2.34
: 3 3.45

This file can be opened in the program with the =open= command. The required first argument of =open= is an =integer= that specifies the /file unit/. Choose any number that is not in use. The unit numbers =0=, =5=, and =6= are reserved for system files and should not be used accidentally. Data is read in *column-major* format, i.e. down each row, one column at a time.

The following code reads the contents of =./data/array.txt= into an array called =array=.

#+begin_src fortran -n
! declare array
real :: array(3,2)
integer :: row

! open file and assign file unit 10
open (10, file='./data/array.txt', action='read')

! read data from file unit 10 into array
do row = 1,3
   read(10,*) array(row,:)
end do

! close file
close(10)
#+end_src

*** Writing data to file

Data can be written to a file with the =write= command.

#+begin_src fortran -n
real :: x
integer :: i, max = 5

! open file, specify unit 10, overwrite if exists
open(10, file='./data/sine.txt', action='write', status='replace')

do i = 0,max
   x = i / real(max)

   ! write to file unit 10
   write(10,*) x, sin(x)
end do
#+end_src

This produces a file =sine.txt= in the directory =data= containing

:   0.00000000       0.00000000    
:  0.200000003      0.198669329    
:  0.400000006      0.389418334    
:  0.600000024      0.564642489    
:  0.800000012      0.717356086    
:   1.00000000      0.841470957    

#+html: </div>
