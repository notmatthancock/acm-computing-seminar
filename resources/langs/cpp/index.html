<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>ACM Computing Seminar C++ Guide</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content=" "/>
<meta name="author" content="Matt Hancock"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color:lightblue; font-weight:normal }
  .target { }
  .timestamp { color: grey }
  .timestamp-kwd { color: CadetBlue }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*/-->
</script>
</head><body>
<h1 class="title">ACM Computing Seminar C++ Guide</h1>


<div id="main">
<div id="footer"><a href="../../../">ACM Computing Seminar Home</a> &mdash; This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.</div>
<a href="javascript:;" id="toc-open">&#9776;</a>
<a href="javascript:;" id="toc-close">&times;</a>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Introduction </a>
<ul>
<li><a href="#sec-1.1">1.1 A little about the language </a></li>
<li><a href="#sec-1.2">1.2 Additional references </a></li>
<li><a href="#sec-1.3">1.3 License, source, etc. </a></li>
</ul>
</li>
<li><a href="#sec-2">2 Getting started </a>
<ul>
<li><a href="#sec-2.1">2.1 Text editors </a></li>
<li><a href="#sec-2.2">2.2 Compilers </a></li>
<li><a href="#sec-2.3">2.3 Writing a program </a></li>
</ul>
</li>
<li><a href="#sec-3">3 Data types </a>
<ul>
<li><a href="#sec-3.1">3.1 The <code>bool</code> type </a></li>
<li><a href="#sec-3.2">3.2 <code>int</code> types </a></li>
<li><a href="#sec-3.3">3.3 Floating point types </a></li>
<li><a href="#sec-3.4">3.4 Casting </a></li>
<li><a href="#sec-3.5">3.5 The <code>const</code> modifier </a></li>
<li><a href="#sec-3.6">3.6 The <code>typedef</code> keyword </a></li>
<li><a href="#sec-3.7">3.7 Pointers and references </a>
<ul>
<li><a href="#sec-3.7.1">3.7.1 Pointers </a></li>
<li><a href="#sec-3.7.2">3.7.2 References </a></li>
</ul>
</li>
<li><a href="#sec-3.8">3.8 Arrays </a>
<ul>
<li><a href="#sec-3.8.1">3.8.1 Fixed length arrays </a></li>
<li><a href="#sec-3.8.2">3.8.2 Dynamic length arrays </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-4">4 Control structures </a>
<ul>
<li><a href="#sec-4.1">4.1 Conditionals </a>
<ul>
<li><a href="#sec-4.1.1">4.1.1 Example: <code>if</code> / <code>else</code> and random number generation </a></li>
<li><a href="#sec-4.1.2">4.1.2 Example: <code>if</code> / <code>else if</code> / <code>else</code> </a></li>
</ul>
</li>
<li><a href="#sec-4.2">4.2 Loops </a>
<ul>
<li><a href="#sec-4.2.1">4.2.1 The <code>for</code> loop </a>
<ul>
<li><a href="#sec-4.2.1.1">4.2.1.1 Example: row-major matrix </a></li>
</ul>
</li>
<li><a href="#sec-4.2.2">4.2.2 The <code>while</code> loop </a>
<ul>
<li><a href="#sec-4.2.2.1">4.2.2.1 Example: truncated sum </a></li>
<li><a href="#sec-4.2.2.2">4.2.2.2 Example: estimating machine epsilon </a></li>
</ul>
</li>
<li><a href="#sec-4.2.3">4.2.3 The <code>break</code> keyword </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-5">5 Input / Output </a>
<ul>
<li><a href="#sec-5.1">5.1 Inputs to <code>main</code>: <code>argc</code> and <code>argv</code> </a></li>
<li><a href="#sec-5.2">5.2 Filestreams </a>
<ul>
<li><a href="#sec-5.2.1">5.2.1 Reading data from a file </a></li>
<li><a href="#sec-5.2.2">5.2.2 Writing data to a file </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-6">6 Functions </a>
<ul>
<li><a href="#sec-6.1">6.1 Writing a function </a>
<ul>
<li><a href="#sec-6.1.1">6.1.1 Example: <code>linspace</code>: generating a set of equally-spaced points </a></li>
</ul>
</li>
<li><a href="#sec-6.2">6.2 Header and implementation files </a>
<ul>
<li><a href="#sec-6.2.1">6.2.1 The header file </a></li>
<li><a href="#sec-6.2.2">6.2.2 The implementation file </a></li>
<li><a href="#sec-6.2.3">6.2.3 The file containing <code>main</code> </a></li>
</ul>
</li>
<li><a href="#sec-6.3">6.3 Function pointers </a>
<ul>
<li><a href="#sec-6.3.1">6.3.1 Example: Newton's method for rootfinding </a></li>
<li><a href="#sec-6.3.2">6.3.2 Example: The midpoint rule for definite integrals </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-7">7 Object-oriented programming </a>
<ul>
<li><a href="#sec-7.1">7.1 Example: a vector <code>class</code> </a>
<ul>
<li><a href="#sec-7.1.1">7.1.1 The header file </a></li>
<li><a href="#sec-7.1.2">7.1.2 The implementation file </a></li>
<li><a href="#sec-7.1.3">7.1.3 Example usage </a></li>
</ul>
</li>
<li><a href="#sec-7.2">7.2 Example cont'd: operator overloading </a>
<ul>
<li><a href="#sec-7.2.1">7.2.1 Overloading <code>operator[]</code> </a></li>
<li><a href="#sec-7.2.2">7.2.2 Overloading <code>operator=</code> </a></li>
</ul>
</li>
<li><a href="#sec-7.3">7.3 Example cont'd: the copy constructor </a></li>
<li><a href="#sec-7.4">7.4 Exampled cont'd: more overloading - <code>operator+</code> </a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">1 Introduction </h2>
<div id="text-1">

<p>This manual is a guide for quickly learning C++ for mathematical and 
scientific computing applications. The goal of this guide is not to 
make you a C++ expert, but to quickly teach you enough of the C++ 
fundamentals and design patterns to help you off the ground. If you 
should like to go beyond this guide, a few references are listed below.
</p>

</div>

<div id="outline-container-1.1" class="outline-3">
<h3 id="sec-1.1">1.1 A little about the language </h3>
<div id="text-1.1">

<p>Before you dive in, here is a little about the C++ programming language:
</p>
<p>
C++ is an extension of the C programming language. Both C and C++ are 
<b>statically-typed</b> and <b>compiled</b> languages, which means that the <b>type</b> 
of variables used in your source code must be declared explicitly and is 
checked when the program is compiled (i.e., translated into a machine 
executable file).
</p>
<p>
One key difference between C++ and C, however, is that C++ provides 
many mechanisms to allow for the <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">object-oriented programming paradigm</a>. This 
essentially allows the software writer to create custom, complex, 
reusable data structures. The object-oriented paradigm is extremely useful, 
but we will only touch the surface of it in this guide.
</p>
</div>

</div>

<div id="outline-container-1.2" class="outline-3">
<h3 id="sec-1.2">1.2 Additional references </h3>
<div id="text-1.2">

<ul>
<li>
<a href="http://cppreference.com">C++ reference</a>
</li>
<li>
<a href="http://www.cplusplus.com/doc/tutorial">C++ tutorials</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/C++">C++ wiki</a>
</li>
<li>
<a href="http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list">A compiled list of C++ textbooks from stackoverflow</a>

</li>
</ul>
</div>

</div>

<div id="outline-container-1.3" class="outline-3">
<h3 id="sec-1.3">1.3 License, source, etc. </h3>
<div id="text-1.3">

<p>This document was created using <a href="https://www.gnu.org/software/emacs/">Emacs</a> <a href="http://orgmode.org/">org mode</a> with some custom css and 
javascript. You can find the license, view the source, and contribute 
to this document here:
</p>
<p>
<a href="https://github.com/notmatthancock/acm-computing-seminar">https://github.com/notmatthancock/acm-computing-seminar</a>
</p>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">2 Getting started </h2>
<div id="text-2">

<p>The particular programming tools that you choose to use will
likely be largely influenced by the operating system that you use.
We will use free tools (often developed for GNU / Linux systems) in
this guide. These tools are mostly available in other operating 
systems as well. For example, on Windows, you could use <a href="https://www.cygwin.com/">Cygwin</a>, or 
install a dual boot with some Linux distribution (e.g., <a href="http://www.ubuntu.com/">Ubuntu</a>). On the 
other hand, MAC OSX, being a BSD-derived system, has many of the 
required tools already available (although, a command line utility, 
<a href="http://brew.sh">Brew</a>, makes building and installing other tools very simple).
</p>
<p>
In the following two sections, we'll talk about the two basic types of 
software that you'll need to begin writing C++ programs.
</p>

</div>

<div id="outline-container-2.1" class="outline-3">
<h3 id="sec-2.1">2.1 Text editors </h3>
<div id="text-2.1">


<p>
The text editor that you choose to use should be be any program 
capable of editing plain text files. However, you may find that it's 
more productive to write in an editor that offers features such as 
syntax highlighting, code-completion, bracket-matching, or other features. 
Here are some popular free text editors:
</p>
<ul>
<li>
<a href="https://atom.io/">Atom</a> is a recently open-sourced GUI editor which some have compared to the very popular non-free editor, <a href="https://sublimetext.com">Sublime Text</a>.
</li>
<li>
<a href="https://www.gnu.org/software/emacs/">Emacs</a> is another powerful editor, which allows for highly optimized workflows.
</li>
<li>
<a href="https://wiki.gnome.org/Apps/Gedit">Gedit</a> is a nice and simple GUI editor, which is the default in GNOME desktop environment.
</li>
<li>
<a href="https://kate-editor.org">Kate</a> is a another simple GUI editor, which is the default in the KDE desktop environment.
</li>
<li>
<a href="http://www.vim.org">Vim</a> is a modal editor with a steep learning curve. It offers highly efficient means to edit text, and is available (or it's predecessor, vi) by default on nearly all UNIX-like operating systems.

</li>
</ul>
</div>

</div>

<div id="outline-container-2.2" class="outline-3">
<h3 id="sec-2.2">2.2 Compilers </h3>
<div id="text-2.2">


<p>
Second, you'll need a program called a <b>compiler</b>. A compiler translates 
the high-level C++ language into an executable program. In this guide, we 
will use the <code>g++</code> compiler which is freely available through the 
<a href="https://gcc.gnu.org/">gnu compiler collection (gcc)</a>.
</p>
<p>
<code>g++</code> is a program which you typically call from the command line, which 
takes as input, your C++ source code file, and produces as output, a 
binary executable file.
</p>
</div>

</div>

<div id="outline-container-2.3" class="outline-3">
<h3 id="sec-2.3">2.3 Writing a program </h3>
<div id="text-2.3">


<p>
Let's create our first C++ program, the obligatory "Hello, world!". First, 
fire-up your text editor and create a file called, <code>hello.cpp</code>, with the 
following contents:
</p>



<pre class="example">
<span class="linenr">1:  </span>  #include &lt;iostream&gt;
<span class="linenr">2:  </span>
<span class="linenr">3:  </span>  int main() {
<span class="linenr">4:  </span>    std::cout &lt;&lt; "Hello, world!";
<span class="linenr">5:  </span>    return 0;
<span class="linenr">6:  </span>  }
</pre>




<p>
Now, to compile the program, execute:
</p>



<pre class="example">
  g++ hello.cpp
</pre>





<p>
Followed by:
</p>


<pre class="example">
  ./a.out
</pre>




<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<col align="left"></col><col align="left"></col>
<tbody>
<tr><td>Hello</td><td>world!</td></tr>
</tbody>
</table>


<p>
By default, <code>g++</code> names the resulting binary executable, <code>a.out</code>, but
you can specify a different output file name by using the <code>-o</code> flag:
</p>



<pre class="example">
  g++ hello.cpp -o my_executable_file.bin
</pre>





<p>
Note that in Windows, executable files typically end in <code>.exe</code>. In Unix-like
systems, there is no particular file-extension type for executables.
</p>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">3 Data types </h2>
<div id="text-3">

<p>As we <a href="#sec-1.1">mentioned previously</a>, you must explicitly declare the type of a 
variable. So, in this section, we'll talk about the main variable 
types you'll use. In the section on <a href="#sec-1.1">object-oriented programming</a>, 
we'll discuss how to build more complex data types.
</p>

</div>

<div id="outline-container-3.1" class="outline-3">
<h3 id="sec-3.1">3.1 The <code>bool</code> type </h3>
<div id="text-3.1">

<p>A boolean data type is either <code>true</code> or <code>false</code>. There are a number of 
operators between these types, illustrated in the code snippet below 
(note that lines starting with <code>//</code> are comments and are ignored by the 
compiler):
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  bool a,b,c; // Declare the type of variables a, b, and c.
<span class="linenr"> 2:  </span>  a = true;
<span class="linenr"> 3:  </span>  b = false;
<span class="linenr"> 4:  </span>
<span class="linenr"> 5:  </span>  // !  is logical negation when applied to a single variable.
<span class="linenr"> 6:  </span>  c = !a; // c is false.
<span class="linenr"> 7:  </span>
<span class="linenr"> 8:  </span>  // &amp;&amp; is logical and.
<span class="linenr"> 9:  </span>  c = (a &amp;&amp; b); // c is false.
<span class="linenr">10:  </span>
<span class="linenr">11:  </span>  // || is logical or.
<span class="linenr">12:  </span>  c = (a || b); // c is true.
</pre>




<p>
We don't often use boolean variables by themselves, but rather as a result 
of comparing two other data types (such as comparing if one integer is less 
than another integer). Expressions that result in boolean values are mostly 
used in <a href="#sec-4.1">conditional control structures</a>.
</p>
</div>

</div>

<div id="outline-container-3.2" class="outline-3">
<h3 id="sec-3.2">3.2 <code>int</code> types </h3>
<div id="text-3.2">


<p>
There are <a href="http://en.cppreference.com/w/cpp/language/types">a variety of integer types</a> in C++. Below, we illustrate a 
couple. These can be modified further using the <code>short</code> and <code>long</code> 
keywords, changing the number of bytes occupied by the variable (and 
hence the maximum and minimum size the variable can take on).
</p>



<pre class="example">
<span class="linenr"> 1:  </span>    int a = 6; // initialize a to 6.
<span class="linenr"> 2:  </span>    unsigned int b = 7; // initialize b to 7.
<span class="linenr"> 3:  </span>    int c; // declare c to be an integer variable.
<span class="linenr"> 4:  </span>
<span class="linenr"> 5:  </span>    a = 6;
<span class="linenr"> 6:  </span>    b = 7;
<span class="linenr"> 7:  </span>
<span class="linenr"> 8:  </span>    c = a / b; // c is 0
<span class="linenr"> 9:  </span>    c = b / a; // c is 1
<span class="linenr">10:  </span>    c = b % a; // c is 1 (% is the integer remainder or modulo operator)
<span class="linenr">11:  </span>    c = a - b; // c is -1
<span class="linenr">12:  </span>    c = a &gt; b; // c is 0 (boolean gets cast to integer)
<span class="linenr">13:  </span>    c = a &lt; b; // c is 1 (boolean gets cast to integer)
<span class="linenr">14:  </span>    c++;       // c is 2 (++ is shorthand for c = c + 1)
<span class="linenr">15:  </span>
<span class="linenr">16:  </span>    b = a - b; // b is 4294967295 (-1 gets cast to unsigned)
<span class="linenr">17:  </span>    b = b + 1; // b is 0 (b was previously the largest unsigned,
<span class="linenr">18:  </span>               // so adding one circles it back to zero.)
<span class="linenr">19:  </span>    b += 7;    // b is 7 (+= is shorthand for b = b + 7;
</pre>




<p>
In the above, we've illustrated the use of signed and unsigned 
integer types and the operators between them. It is important to 
take care when you assign a result to a variable that doesn't match 
the type of the result. In many cases, the result gets implicitly 
cast to the type of variable being assigned to. The result may or 
may not match your expectations, as shown above.
</p>
</div>

</div>

<div id="outline-container-3.3" class="outline-3">
<h3 id="sec-3.3">3.3 Floating point types </h3>
<div id="text-3.3">

<p>There are two main floating point data types in C++, <code>float</code> and <code>double</code>,
which correspond to <a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 32- and 64-bit floating point types</a>. 
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  #include &lt;iostream&gt;
<span class="linenr"> 2:  </span>  #include &lt;limits&gt;
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>  int main() {
<span class="linenr"> 5:  </span>    float a; //  Declare a single precision float.
<span class="linenr"> 6:  </span>    double b; // Declare a double precision float.
<span class="linenr"> 7:  </span>
<span class="linenr"> 8:  </span>    // Print the max value of a float type.
<span class="linenr"> 9:  </span>    std::cout &lt;&lt; std::numeric_limits&lt;float&gt;::max() &lt;&lt; std::endl;
<span class="linenr">10:  </span>
<span class="linenr">11:  </span>    // Print the max value of a double type.
<span class="linenr">12:  </span>    std::cout &lt;&lt; std::numeric_limits&lt;double&gt;::max() &lt;&lt; std::endl;
<span class="linenr">13:  </span>
<span class="linenr">14:  </span>    // Print machine epsilon of a float type.
<span class="linenr">15:  </span>    std::cout &lt;&lt; std::numeric_limits&lt;float&gt;::epsilon() &lt;&lt; std::endl;
<span class="linenr">16:  </span>
<span class="linenr">17:  </span>    // Print machine epsilon of a double type.
<span class="linenr">18:  </span>    std::cout &lt;&lt; std::numeric_limits&lt;double&gt;::epsilon() &lt;&lt; std::endl;
<span class="linenr">19:  </span>
<span class="linenr">20:  </span>    return 0;
<span class="linenr">21:  </span>  }
</pre>




: 3.40282e+38
: 1.79769e+308
: 1.19209e-07
: 2.22045e-16

</div>

</div>

<div id="outline-container-3.4" class="outline-3">
<h3 id="sec-3.4">3.4 Casting </h3>
<div id="text-3.4">


<p>
Sometimes it is useful to explicitly cast one variable type as another. 
This can be done like the following:
</p>



<pre class="example">
<span class="linenr">1:  </span>  int a; double b = 3.14159;
<span class="linenr">2:  </span>
<span class="linenr">3:  </span>  a = (int) b;
<span class="linenr">4:  </span>
<span class="linenr">5:  </span>  std::cout &lt;&lt; a &lt;&lt; std::endl;
</pre>




: 3

</div>

</div>

<div id="outline-container-3.5" class="outline-3">
<h3 id="sec-3.5">3.5 The <code>const</code> modifier </h3>
<div id="text-3.5">


<p>
If the value of some variable should not change, you can use the <code>const</code>
keyword to protect its status. It is typical to denote <code>const</code> variables 
with all caps. Try to compile the following program:
</p>



<pre class="example">
<span class="linenr">1:  </span>  const double PI = 3.14159;
<span class="linenr">2:  </span>
<span class="linenr">3:  </span>  PI = 3.0;
</pre>





<p>
You will see an error like, <code>error: assignment of read-only variable ‘PI’</code>. 
</p>
</div>

</div>

<div id="outline-container-3.6" class="outline-3">
<h3 id="sec-3.6">3.6 The <code>typedef</code> keyword </h3>
<div id="text-3.6">

<p>Suppose you have a large numerical experiment, where all your code used 
floating point of type <code>double</code>. Your curious about how the results will 
be affected by changing the floating point type to single precision <code>float</code>
type. One solution would be to run a "find and replace" in your editor, but 
something about that doesn't feel right.
</p>
<p>
Instead, we can use the <code>typedef</code> statement to define types:
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  // Define "int_type" to be a short int.
<span class="linenr"> 2:  </span>  typedef short int int_type;
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>  // Define "float_type" to be single precision float.
<span class="linenr"> 5:  </span>  typedef float float_type;
<span class="linenr"> 6:  </span>
<span class="linenr"> 7:  </span>  // Define "array_index_type" to be unsigned long int.
<span class="linenr"> 8:  </span>  typedef unsigned long int array_index_type;
<span class="linenr"> 9:  </span>
<span class="linenr">10:  </span>  int_type a = -17; 
<span class="linenr">11:  </span>  float_type b = 1.14; 
<span class="linenr">12:  </span>  array_index_type c = 9;
</pre>





</div>

</div>

<div id="outline-container-3.7" class="outline-3">
<h3 id="sec-3.7">3.7 Pointers and references </h3>
<div id="text-3.7">


</div>

<div id="outline-container-3.7.1" class="outline-4">
<h4 id="sec-3.7.1">3.7.1 Pointers </h4>
<div id="text-3.7.1">

<p>Pointers are variables that hold the <b>memory address</b> for a variable 
of a specific type. Pointers are declared by specifying the variable 
type, followed by the <code>*</code> symbol, followed by the name of the pointer 
variable, e.g., <code>double * x</code> defines a "pointer to double" variable. 
The variable, <code>x</code>, therefore, does not hold the value of a <code>double</code> 
type, but rather, the memory address for a variable of type, <code>double</code>.
The memory address for a variable can be obtained by the <code>&amp;</code> operator.
</p>



<pre class="example">
<span class="linenr">1:  </span>  double * a;
<span class="linenr">2:  </span>  double b = 7;
<span class="linenr">3:  </span>  
<span class="linenr">4:  </span>  // This obtains the memory address of `b`.
<span class="linenr">5:  </span>  a = &amp;b;
<span class="linenr">6:  </span>  
<span class="linenr">7:  </span>  // Prints some memory address (starts with 0x)
<span class="linenr">8:  </span>  std::cout &lt;&lt; a &lt;&lt; std::endl;
</pre>




: 0x7ffe0d98f7b8

<p>
Similar to obtaining the memory address from a regular variable, using the
<code>&amp;</code> operator, you can use the <code>*</code> symbol before a pointer to access the 
variable value held at the memory location of the pointer. In this context,
the <code>*</code> symbol is called the <b>dereference operator</b>. This is probably better 
understood with a short example:
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  double * a;
<span class="linenr"> 2:  </span>  double b = 7.3;
<span class="linenr"> 3:  </span>  double c;
<span class="linenr"> 4:  </span>
<span class="linenr"> 5:  </span>  // Now `a` holds the memory address of `b`.
<span class="linenr"> 6:  </span>  a = &amp;b;
<span class="linenr"> 7:  </span>
<span class="linenr"> 8:  </span>  // `*a` obtains the value of the variable
<span class="linenr"> 9:  </span>  // at the memory address held by `a`.
<span class="linenr">10:  </span>  // So, `c` is 7.3.
<span class="linenr">11:  </span>  c = *a;
<span class="linenr">12:  </span>
<span class="linenr">13:  </span>  std::cout &lt;&lt; c &lt;&lt; "\n";
</pre>




: 7.3

</div>

</div>

<div id="outline-container-3.7.2" class="outline-4">
<h4 id="sec-3.7.2">3.7.2 References </h4>
<div id="text-3.7.2">


<p>
A reference is a sort of like a pointer, but not quite. <a href="https://en.wikipedia.org/wiki/Reference_(C++)">There are differences</a>.
A good analogy, which you can find in the previous link, is that a reference
is similar to a symbolic link, or "shortcut" if you're on Windows. You can 
treat it more-or-less like the original variable, but it's not the original.
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  double a = 1.1;
<span class="linenr"> 2:  </span>  // `b` is a reference to `a`.
<span class="linenr"> 3:  </span>  double &amp; b = a;
<span class="linenr"> 4:  </span>
<span class="linenr"> 5:  </span>  std::cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; ", b: " &lt;&lt; b &lt;&lt; "\n";
<span class="linenr"> 6:  </span>
<span class="linenr"> 7:  </span>  a = 2.1;
<span class="linenr"> 8:  </span>
<span class="linenr"> 9:  </span>  std::cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; ", b: " &lt;&lt; b &lt;&lt; "\n";
<span class="linenr">10:  </span>
<span class="linenr">11:  </span>  b = 3.1;
<span class="linenr">12:  </span>
<span class="linenr">13:  </span>  std::cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; ", b: " &lt;&lt; b &lt;&lt; "\n";
<span class="linenr">14:  </span>
<span class="linenr">15:  </span>  std::cout &lt;&lt; "\n\n";
<span class="linenr">16:  </span>  std::cout &lt;&lt; "&amp;a: " &lt;&lt; &amp;a &lt;&lt; "\n" &lt;&lt; "&amp;b: " &lt;&lt; &amp;b &lt;&lt; "\n";
</pre>




: a: 1.1, b: 1.1
: a: 2.1, b: 2.1
: a: 3.1, b: 3.1
: 
: 
: &a: 0x7ffcfbe7b1e8
: &b: 0x7ffcfbe7b1e8

<p>
References are useful for passing around large objects, so that the object
doesn't need to be copied. References are also useful as a return type for 
functions <a href="#sec-3.7.2">(to be discussed later)</a> because it allows to assign to assign a 
value to a function, which is useful if the function, for example, returns 
a reference to the element of an array.
</p>
</div>
</div>

</div>

<div id="outline-container-3.8" class="outline-3">
<h3 id="sec-3.8">3.8 Arrays </h3>
<div id="text-3.8">

<p>The length of an array can be fixed or dynamic, and how you
declare the array depends on this. Array indexing starts at 0 in C++ 
(compared to start at 1, for example, in Fortran or Matlab).
</p>

</div>

<div id="outline-container-3.8.1" class="outline-4">
<h4 id="sec-3.8.1">3.8.1 Fixed length arrays </h4>
<div id="text-3.8.1">




<pre class="example">
<span class="linenr">1:  </span>double a[5];
<span class="linenr">2:  </span>
<span class="linenr">3:  </span>a[0] = 1.0;
<span class="linenr">4:  </span>// etc.
</pre>





</div>

</div>

<div id="outline-container-3.8.2" class="outline-4">
<h4 id="sec-3.8.2">3.8.2 Dynamic length arrays </h4>
<div id="text-3.8.2">

<p>Dynamic length arrays are made possible through pointers:
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  // This allocates memory for 5 double types.
<span class="linenr"> 2:  </span>  double * a = new double[5];
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>  // Afterwards, you can treat `a` like a normal array.
<span class="linenr"> 5:  </span>  a[0] = 1.0;
<span class="linenr"> 6:  </span>  // etc...
<span class="linenr"> 7:  </span>
<span class="linenr"> 8:  </span>  // Whenever you use the `new` keyword, you must
<span class="linenr"> 9:  </span>  // delete the memory allocated when you're done by hand.
<span class="linenr">10:  </span>  delete [] a;
<span class="linenr">11:  </span>
<span class="linenr">12:  </span>  // We can change the size of `a`.
<span class="linenr">13:  </span>  a = new double [10];
<span class="linenr">14:  </span>
<span class="linenr">15:  </span>  a[0] = 2.0;
<span class="linenr">16:  </span>  // etc...
<span class="linenr">17:  </span>
<span class="linenr">18:  </span>  delete [] a;
</pre>





<p>
Note that omitting the first <code>delete</code> statement will cause no error. 
However, the memory allocated by the first <code>new</code> statement will not 
be freed, and thus inaccessible. This is bad because the memory cannot 
be allocated to other resources. You should generally try to avoid 
manually memory management when possible, but a good tool for debugging 
memory problems is called <a href="http://valgrind.org/">valgrind</a>. 
</p>

</div>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">4 Control structures </h2>
<div id="text-4">


</div>

<div id="outline-container-4.1" class="outline-3">
<h3 id="sec-4.1">4.1 Conditionals </h3>
<div id="text-4.1">


</div>

<div id="outline-container-4.1.1" class="outline-4">
<h4 id="sec-4.1.1">4.1.1 Example: <code>if</code> / <code>else</code> and random number generation </h4>
<div id="text-4.1.1">

<p>Often a code block should only be executed if some condition is true. 
Below, we generate a random number between 0 and 1; print the number; and,
print whether or not the number was greater than 0.5.
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  #include &lt;iostream&gt;
<span class="linenr"> 2:  </span>  #include &lt;stdlib.h&gt;
<span class="linenr"> 3:  </span>  #include &lt;time.h&gt;
<span class="linenr"> 4:  </span>
<span class="linenr"> 5:  </span>  int main() {
<span class="linenr"> 6:  </span>    // Seed a random number generator.
<span class="linenr"> 7:  </span>    srand(123);
<span class="linenr"> 8:  </span>
<span class="linenr"> 9:  </span>    // rand() produces a random integer between 0 and RAND_MAX.
<span class="linenr">10:  </span>    double num = rand() / ((double) RAND_MAX);
<span class="linenr">11:  </span>
<span class="linenr">12:  </span>    std::cout &lt;&lt; "num: " &lt;&lt; num &lt;&lt; "\n";
<span class="linenr">13:  </span>
<span class="linenr">14:  </span>    if (num &lt; 0.5) {
<span class="linenr">15:  </span>      std::cout &lt;&lt; "num was less than 0.5.\n";
<span class="linenr">16:  </span>    }
<span class="linenr">17:  </span>    else {
<span class="linenr">18:  </span>      std::cout &lt;&lt; "num was greater than 0.5.\n";
<span class="linenr">19:  </span>    }
<span class="linenr">20:  </span>
<span class="linenr">21:  </span>    // Do it again.
<span class="linenr">22:  </span>    num = rand() / ((double) RAND_MAX);
<span class="linenr">23:  </span>
<span class="linenr">24:  </span>    std::cout &lt;&lt; "num: " &lt;&lt; num &lt;&lt; "\n";
<span class="linenr">25:  </span>
<span class="linenr">26:  </span>    if (num &lt; 0.5) {
<span class="linenr">27:  </span>      std::cout &lt;&lt; "num was less than 0.5.\n";
<span class="linenr">28:  </span>    }
<span class="linenr">29:  </span>    else {
<span class="linenr">30:  </span>      std::cout &lt;&lt; "num was greater than 0.5.\n";
<span class="linenr">31:  </span>    }
<span class="linenr">32:  </span>
<span class="linenr">33:  </span>    return 0;
<span class="linenr">34:  </span>  }
</pre>




: num: 0.0600514
: num was less than 0.5.
: num: 0.788318
: num was greater than 0.5.

</div>

</div>

<div id="outline-container-4.1.2" class="outline-4">
<h4 id="sec-4.1.2">4.1.2 Example: <code>if</code> / <code>else if</code> / <code>else</code> </h4>
<div id="text-4.1.2">


<p>
You can follow <code>else</code> immediate by another <code>if</code> to have multiple mutually-
exclusive blocks:
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  #include &lt;iostream&gt;
<span class="linenr"> 2:  </span>  #include &lt;stdlib.h&gt;
<span class="linenr"> 3:  </span>  #include &lt;time.h&gt;
<span class="linenr"> 4:  </span>
<span class="linenr"> 5:  </span>  int main() {
<span class="linenr"> 6:  </span>    // Seed the random number generator based on the current time.
<span class="linenr"> 7:  </span>    srand(time(NULL));
<span class="linenr"> 8:  </span>
<span class="linenr"> 9:  </span>    // rand() produces a random integer between 0 and RAND_MAX.
<span class="linenr">10:  </span>    double num = rand() / ((double) RAND_MAX);
<span class="linenr">11:  </span>
<span class="linenr">12:  </span>    std::cout &lt;&lt; "num: " &lt;&lt; num &lt;&lt; "\n";
<span class="linenr">13:  </span>
<span class="linenr">14:  </span>    if (num &gt;= 0.75) {
<span class="linenr">15:  </span>      std::cout &lt;&lt; "num was between 0.75 and 1.\n";
<span class="linenr">16:  </span>    }
<span class="linenr">17:  </span>    else if (num &gt;= 0.5) {
<span class="linenr">18:  </span>      std::cout &lt;&lt; "num was between 0.5 and 0.75.";
<span class="linenr">19:  </span>    }
<span class="linenr">20:  </span>    else if (num &gt;= 0.25) {
<span class="linenr">21:  </span>      std::cout &lt;&lt; "num was between 0.25 and 0.5.";
<span class="linenr">22:  </span>    }
<span class="linenr">23:  </span>    else {
<span class="linenr">24:  </span>      std::cout &lt;&lt; "num was between 0 and 0.25";
<span class="linenr">25:  </span>    }
<span class="linenr">26:  </span>
<span class="linenr">27:  </span>    return 0;
<span class="linenr">28:  </span>  }
</pre>




: num: 0.0456405
: num was between 0 and 0.25

<p>
The conditions are checked in the order that they're written. So, for example,
in the second condition, we don't need to specify <code>num &gt;= 0.5 &amp;&amp; num &lt; 0.75</code> 
because we know that this condition will only be checked if the previous 
was false.
</p>
</div>
</div>

</div>

<div id="outline-container-4.2" class="outline-3">
<h3 id="sec-4.2">4.2 Loops </h3>
<div id="text-4.2">

<p>We discuss two main structures for iterating &ndash; the <code>for</code> and <code>while</code> loops.
</p>
</div>

<div id="outline-container-4.2.1" class="outline-4">
<h4 id="sec-4.2.1">4.2.1 The <code>for</code> loop </h4>
<div id="text-4.2.1">

<p>The <code>for</code> loop requires three specifications &ndash; the iteration variable 
initialization, the termination condition, and the update rule. The body
of the loop follows these three specifications. Shown below, we declare 
an array; assign to its components; and, print the current component to 
the screen.
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  int length = 11;
<span class="linenr"> 2:  </span>  double x[length];
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>  for(int i=0; i &lt; length; i++) {
<span class="linenr"> 5:  </span>    // Assign to each array component.
<span class="linenr"> 6:  </span>    x[i] = (double) i / (length - 1);
<span class="linenr"> 7:  </span>
<span class="linenr"> 8:  </span>    // Print the current component.
<span class="linenr"> 9:  </span>    std::cout &lt;&lt; "x[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; x[i] &lt;&lt; std::endl;
<span class="linenr">10:  </span>  }
</pre>





<pre class="example">
x[0] = 0
x[1] = 0.1
x[2] = 0.2
x[3] = 0.3
x[4] = 0.4
x[5] = 0.5
x[6] = 0.6
x[7] = 0.7
x[8] = 0.8
x[9] = 0.9
x[10] = 1
</pre>






</div>

<div id="outline-container-4.2.1.1" class="outline-5">
<h5 id="sec-4.2.1.1">4.2.1.1 Example: row-major matrix </h5>
<div id="text-4.2.1.1">


<p>
You can nest loops, i.e., loops inside of loops, etc.
</p>
<p>
Below, is an example of a double loop for creating and accessing 
matrix data stored in a flat array. The matrix data is stored in 
<a href="https://en.wikipedia.org/wiki/Row-major-order">row-major order</a>. This means the first <code>n_cols</code> elements of the 
array named, <code>matrix</code>, will contain the first row of the matrix, 
the second <code>n_cols</code> elements of <code>matrix</code> will contain the second row, etc.
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  int n_rows = 4;
<span class="linenr"> 2:  </span>  int n_cols = 3;
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>  // Row-major matrix array.
<span class="linenr"> 5:  </span>  double matrix [n_rows*n_cols];
<span class="linenr"> 6:  </span>
<span class="linenr"> 7:  </span>  // temporary index.
<span class="linenr"> 8:  </span>  int k;
<span class="linenr"> 9:  </span>
<span class="linenr">10:  </span>  for(int i=0; i &lt; n_rows; i++) {
<span class="linenr">11:  </span>    for(int j=0; j &lt; n_cols; j++) {
<span class="linenr">12:  </span>      // Convert the (i,j) matrix index to the "flat" row-major index.
<span class="linenr">13:  </span>      k = i*n_cols + j;
<span class="linenr">14:  </span>
<span class="linenr">15:  </span>      // Assign a value of 1.0 to the diagonal,
<span class="linenr">16:  </span>      // 2 to the off-diagonal, and 0 otherwise.
<span class="linenr">17:  </span>      if (i == j) {
<span class="linenr">18:  </span>        matrix[k] = 1.0;
<span class="linenr">19:  </span>      }
<span class="linenr">20:  </span>      else if ((i == (j+1)) || (i == (j-1))){
<span class="linenr">21:  </span>        matrix[k] = 2.0;
<span class="linenr">22:  </span>      }
<span class="linenr">23:  </span>      else {
<span class="linenr">24:  </span>        matrix[k] = 0.0;
<span class="linenr">25:  </span>      }
<span class="linenr">26:  </span>    }
<span class="linenr">27:  </span>  }
<span class="linenr">28:  </span>
<span class="linenr">29:  </span>
<span class="linenr">30:  </span>  // Print the matrix elements.
<span class="linenr">31:  </span>  for(int i=0; i &lt; n_rows; i++) {
<span class="linenr">32:  </span>    for(int j=0; j &lt; n_cols; j++) {
<span class="linenr">33:  </span>      k = i*n_cols + j;
<span class="linenr">34:  </span>
<span class="linenr">35:  </span>      std::cout &lt;&lt; matrix[k];
<span class="linenr">36:  </span>      if (j != (n_cols-1)) {
<span class="linenr">37:  </span>        std::cout &lt;&lt; ", ";
<span class="linenr">38:  </span>      }
<span class="linenr">39:  </span>    }
<span class="linenr">40:  </span>
<span class="linenr">41:  </span>    if (i != (n_rows-1)) {
<span class="linenr">42:  </span>      std::cout &lt;&lt; "\n";
<span class="linenr">43:  </span>    }
<span class="linenr">44:  </span>  }
</pre>




: 1, 2, 0
: 2, 1, 2
: 0, 2, 1
: 0, 0, 2

</div>
</div>

</div>

<div id="outline-container-4.2.2" class="outline-4">
<h4 id="sec-4.2.2">4.2.2 The <code>while</code> loop </h4>
<div id="text-4.2.2">

<p>A <code>while</code> loop iterates while a condition is <code>true</code>. Essentially, it is a <code>for</code>
loop without an update variable.
</p>

</div>

<div id="outline-container-4.2.2.1" class="outline-5">
<h5 id="sec-4.2.2.1">4.2.2.1 Example: truncated sum </h5>
<div id="text-4.2.2.1">

<p>In the following example, we approximate the geometric series:
</p>
<p>
$$
1 = &sum;<sub>n=1</sub>^{&infin;} \left(\frac{1}{2}\right)<sup>n</sup>
$$
</p>
<p>
The loop exits when the absolute error, 
</p>
<p>
$$
\text{absolute error} := 1-&sum;<sub>n=1</sub><sup>N</sup>  \left(\frac{1}{2}\right)<sup>n</sup>
$$
</p>
<p>
is less than some specified tolerance, <code>tol</code>.
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  double sum = 0.0;
<span class="linenr"> 2:  </span>  double base = 0.5;
<span class="linenr"> 3:  </span>  double pow = base; // initialize to base^1
<span class="linenr"> 4:  </span>  double tol = 1e-4;
<span class="linenr"> 5:  </span>  int iter = 1;
<span class="linenr"> 6:  </span>
<span class="linenr"> 7:  </span>  while((1-sum) &gt;= tol) {
<span class="linenr"> 8:  </span>    // Add `pow` to `sum`.
<span class="linenr"> 9:  </span>    sum += pow;
<span class="linenr">10:  </span>    // Update `pow` by one power of `base`.
<span class="linenr">11:  </span>    pow *= base;
<span class="linenr">12:  </span>
<span class="linenr">13:  </span>    printf("Iter: %03d, Sum: %.5f, Abs Err: %.5f\n", iter, sum, 1-sum); 
<span class="linenr">14:  </span>
<span class="linenr">15:  </span>    // Update the `iter` val by 1.
<span class="linenr">16:  </span>    iter += 1;
<span class="linenr">17:  </span>  }
</pre>





<pre class="example">
Iter: 001, Sum: 0.50000, Abs Err: 0.50000
Iter: 002, Sum: 0.75000, Abs Err: 0.25000
Iter: 003, Sum: 0.87500, Abs Err: 0.12500
Iter: 004, Sum: 0.93750, Abs Err: 0.06250
Iter: 005, Sum: 0.96875, Abs Err: 0.03125
Iter: 006, Sum: 0.98438, Abs Err: 0.01562
Iter: 007, Sum: 0.99219, Abs Err: 0.00781
Iter: 008, Sum: 0.99609, Abs Err: 0.00391
Iter: 009, Sum: 0.99805, Abs Err: 0.00195
Iter: 010, Sum: 0.99902, Abs Err: 0.00098
Iter: 011, Sum: 0.99951, Abs Err: 0.00049
Iter: 012, Sum: 0.99976, Abs Err: 0.00024
Iter: 013, Sum: 0.99988, Abs Err: 0.00012
Iter: 014, Sum: 0.99994, Abs Err: 0.00006
</pre>




</div>

</div>

<div id="outline-container-4.2.2.2" class="outline-5">
<h5 id="sec-4.2.2.2">4.2.2.2 Example: estimating machine epsilon </h5>
<div id="text-4.2.2.2">





<pre class="example">
<span class="linenr"> 1:  </span>  double eps = 1;
<span class="linenr"> 2:  </span>  int count = 1;
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>  while(1.0 + eps*0.5 &gt; 1.0) {
<span class="linenr"> 5:  </span>      eps *= 0.5;
<span class="linenr"> 6:  </span>      count += 1;
<span class="linenr"> 7:  </span>  }
<span class="linenr"> 8:  </span>
<span class="linenr"> 9:  </span>  std::cout &lt;&lt; eps &lt;&lt; ", " &lt;&lt; std::numeric_limits&lt;double&gt;::epsilon() &lt;&lt; "\n"
<span class="linenr">10:  </span>            &lt;&lt; count &lt;&lt; ", " &lt;&lt; std::numeric_limits&lt;double&gt;::digits;
</pre>




: 2.22045e-16, 2.22045e-16
: 53, 53

</div>
</div>

</div>

<div id="outline-container-4.2.3" class="outline-4">
<h4 id="sec-4.2.3">4.2.3 The <code>break</code> keyword </h4>
<div id="text-4.2.3">

<p>The <code>break</code> keyword provides a mechanism for exiting the direct parent loop
for which the <code>break</code> statement is placed. For example:
</p>



<pre class="example">
<span class="linenr">1:  </span>  for(int i=0; i &lt; 3; i++) {
<span class="linenr">2:  </span>    while(true) {
<span class="linenr">3:  </span>      std::cout &lt;&lt; "Entering infinite loop number " &lt;&lt; (i+1) &lt;&lt; "\n";
<span class="linenr">4:  </span>      break;
<span class="linenr">5:  </span>    }
<span class="linenr">6:  </span>    std::cout &lt;&lt; "We escaped the infinite loop!\n";
<span class="linenr">7:  </span>  }
</pre>




: Entering infinite loop number 1
: We escaped the infinite loop!
: Entering infinite loop number 2
: We escaped the infinite loop!
: Entering infinite loop number 3
: We escaped the infinite loop!

<p>
The previous example is contrived, but there are situations, where you
might find the break statement within an infinite loop useful. Of course,
you should avoid this sort of thing if there is a more straight-forward 
approach.
</p>


</div>
</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">5 Input / Output </h2>
<div id="text-5">

<p>We have already used the <code>&lt;iostream&gt;</code> library to print results to 
the console. However, in many cases, we'd like to read in lots of 
data from a file, pass option flags to the program from the command 
line, or save the results of some computation to a file for further 
analysis.
</p>

</div>

<div id="outline-container-5.1" class="outline-3">
<h3 id="sec-5.1">5.1 Inputs to <code>main</code>: <code>argc</code> and <code>argv</code> </h3>
<div id="text-5.1">

<p>The <code>main</code> function has two optional arguments which we have thus far omitted, 
<code>argc</code> and <code>argv</code>. These arguments allow arguments to passed to the <code>main</code> 
function when the program is run. This is how flags and other arguments are 
passed to programs you use from the command line. The first, <code>argc</code>, is of 
type, <code>int</code>, and stands for arg count. It gives the number of arguments 
to the program. The arg count is always at least 1 because the program's 
name is always the first argument. The second, <code>argv</code>, is a double pointer to
<code>char</code>. In essence, <code>argv</code> is an array of strings.
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  #include &lt;iostream&gt;
<span class="linenr"> 2:  </span>
<span class="linenr"> 3:  </span>  int main(int argc, char ** argv) {
<span class="linenr"> 4:  </span>    std::cout &lt;&lt; "argc = " &lt;&lt; argc &lt;&lt; "\n";
<span class="linenr"> 5:  </span>
<span class="linenr"> 6:  </span>    for(int i=0; i &lt; argc; i++) {
<span class="linenr"> 7:  </span>      std::cout &lt;&lt; "argv[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; argv[i] &lt;&lt; "\n";
<span class="linenr"> 8:  </span>    }
<span class="linenr"> 9:  </span>    return 0;
<span class="linenr">10:  </span>  }
</pre>




<p>
Compile this program, and run, for example:
</p>



<pre class="example">
  g++ main.cpp
  ./a.out hello 1 2 34
</pre>




: argc = 5
: argv[0] = ./a.out
: argv[1] = hello
: argv[2] = 1
: argv[3] = 2
: argv[4] = 34

<p>
<code>argc</code> and <code>argv</code> are handy for setting up large experiments. You could, for 
example, set up your main function so that different functions or parameters 
or used based on the arguments of <code>arcv</code>. Then, you could set up a shell 
script that loops through the desired arguments to be supplied to the main 
function.
</p>
</div>

</div>

<div id="outline-container-5.2" class="outline-3">
<h3 id="sec-5.2">5.2 Filestreams </h3>
<div id="text-5.2">

<p>File input and output is crucial for numerical experiments with lots of data. 
In this section, we see how to read and write data to files.
</p>

</div>

<div id="outline-container-5.2.1" class="outline-4">
<h4 id="sec-5.2.1">5.2.1 Reading data from a file </h4>
<div id="text-5.2.1">


<p>
In general, how data is read in depends heavily on how the data is stored. 
Nevertheless, we will give an example of reading in a vector stored in a 
particular fashion. Suppose a text file exists in the directory, 
<code>./data/vector.txt</code>, containing
</p>
<pre class="example">
1 2 3.14 4 5 6.28
</pre>




<pre class="example">
<span class="linenr"> 1:  </span>#include &lt;iostream&gt;
<span class="linenr"> 2:  </span>#include &lt;fstream&gt;
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>int main() {
<span class="linenr"> 5:  </span>    std::fstream fin("./data/vector.txt", std::ios_base::in);
<span class="linenr"> 6:  </span>    double vector[6];
<span class="linenr"> 7:  </span>    int i = 0;
<span class="linenr"> 8:  </span>    while(fin &gt;&gt; vector[i]) {
<span class="linenr"> 9:  </span>      std::cout &lt;&lt; vector[i] &lt;&lt; " ";
<span class="linenr">10:  </span>      i++;
<span class="linenr">11:  </span>    }
<span class="linenr">12:  </span>    return 0;
<span class="linenr">13:  </span>}
</pre>





<pre class="example">
  g++ main.cpp &amp;&amp; ./a.out
</pre>




: 1 2 3.14 4 5 6.28

<p>
This simply prints the data in the file back out to the console. Note, however, 
that the data is read into an array of type <code>double</code>, so it can be processed 
numerically thereafter.
</p>
<p>
In this example dealt with simply stored data, and it was 
assumed that the number of data entries was known beforehand. Parsing 
data can become quite complicated depending on how it is stored, and 
depending on the intended format of the data.
</p>
</div>

</div>

<div id="outline-container-5.2.2" class="outline-4">
<h4 id="sec-5.2.2">5.2.2 Writing data to a file </h4>
<div id="text-5.2.2">


<p>
Writing to a file is similar, using the <code>&lt;fstream&gt;</code> library.
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  #include &lt;fstream&gt;
<span class="linenr"> 2:  </span>  #include &lt;cmath&gt;
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>  int main() {
<span class="linenr"> 5:  </span>    std::fstream fout("./data/new_shiny_data.txt", std::ios_base::out);
<span class="linenr"> 6:  </span>    double x;
<span class="linenr"> 7:  </span>
<span class="linenr"> 8:  </span>    fout &lt;&lt; "x\tsin(x)\n";
<span class="linenr"> 9:  </span>
<span class="linenr">10:  </span>    for(int i=0; i &lt; 11; i++) {
<span class="linenr">11:  </span>      x = i / 10.0;
<span class="linenr">12:  </span>      fout &lt;&lt; x &lt;&lt; "\t" &lt;&lt; sin(x) &lt;&lt; "\n";
<span class="linenr">13:  </span>    }
<span class="linenr">14:  </span>
<span class="linenr">15:  </span>    fout.close();
<span class="linenr">16:  </span>
<span class="linenr">17:  </span>    return 0;
<span class="linenr">18:  </span>  }
</pre>






<pre class="example">
  g++ main.cpp &amp;&amp; ./a.out
</pre>





<p>
This produces a file called <code>new_shiny_data.txt</code> in the folder, <code>data</code>, 
containing:
</p>



<pre class="example">
x	sin(x)
0	0
0.1	0.0998334
0.2	0.198669
0.3	0.29552
0.4	0.389418
0.5	0.479426
0.6	0.564642
0.7	0.644218
0.8	0.717356
0.9	0.783327
1	0.841471
</pre>




</div>
</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">6 Functions </h2>
<div id="text-6">


<p>
So far, we've piled everything into the <code>main</code> function. When we have a block of 
code used for a specific subtask, we can offload it to a function. This promotes 
code which is separated based on the subtasks each block is intended to perform. 
This, in turn, makes your code easier to debug and easier to understand.  
</p>

</div>

<div id="outline-container-6.1" class="outline-3">
<h3 id="sec-6.1">6.1 Writing a function </h3>
<div id="text-6.1">


<p>
A function must be declared before use. Thus, a function usual consists of two
parts, a declaration and an implementation. You must declare the return type 
of a function as well as the types of all the function's arguments. If the 
function is defined in the same file as the <code>main</code> function, you should write
the declaration before <code>main</code> and the implementation after <code>main</code>.
</p>

</div>

<div id="outline-container-6.1.1" class="outline-4">
<h4 id="sec-6.1.1">6.1.1 Example: <code>linspace</code>: generating a set of equally-spaced points </h4>
<div id="text-6.1.1">





<pre class="example">
<span class="linenr"> 1:  </span>  #include &lt;iostream&gt;
<span class="linenr"> 2:  </span>
<span class="linenr"> 3:  </span>  // This is the function declaration.
<span class="linenr"> 4:  </span>  // You should describe the functions arguments
<span class="linenr"> 5:  </span>  // and what is returned by the function in comments
<span class="linenr"> 6:  </span>  // near the declaration.
<span class="linenr"> 7:  </span>  //
<span class="linenr"> 8:  </span>  // `linspace` returns an array of doubles containing
<span class="linenr"> 9:  </span>  // `n_points` entries which are equally-spaced, starting
<span class="linenr">10:  </span>  // at `start` and ending at `stop`.
<span class="linenr">11:  </span>  double * linspace(double start, double stop, int n_points);
<span class="linenr">12:  </span>
<span class="linenr">13:  </span>  // `void` is a function with no return type.
<span class="linenr">14:  </span>  // `print_array` takes an array and prints it to std out.
<span class="linenr">15:  </span>  void print_array(double * arr, int arr_len);
<span class="linenr">16:  </span>
<span class="linenr">17:  </span>  int main() {
<span class="linenr">18:  </span>    double * xs = linspace(-1, 1, 5);
<span class="linenr">19:  </span>    print_array(xs, 5);
<span class="linenr">20:  </span>    delete [] xs;
<span class="linenr">21:  </span>
<span class="linenr">22:  </span>    return 0;
<span class="linenr">23:  </span>  }
<span class="linenr">24:  </span>
<span class="linenr">25:  </span>  // Implementation of `linspace`.
<span class="linenr">26:  </span>  double * linspace(double start, double stop, int n_points) {
<span class="linenr">27:  </span>    double * arr = new double [n_points];
<span class="linenr">28:  </span>    double dx = (stop-start) / (n_points-1.0);
<span class="linenr">29:  </span>
<span class="linenr">30:  </span>    for(int i=0; i &lt; n_points; i++) {
<span class="linenr">31:  </span>      arr[i] = start + i*dx;
<span class="linenr">32:  </span>    }
<span class="linenr">33:  </span>
<span class="linenr">34:  </span>    return arr;
<span class="linenr">35:  </span>  }
<span class="linenr">36:  </span>
<span class="linenr">37:  </span>  // Implementation of `print_array`.
<span class="linenr">38:  </span>  void print_array(double * arr, int arr_len) {
<span class="linenr">39:  </span>    for(int i=0; i &lt; arr_len; i++) {
<span class="linenr">40:  </span>      std::cout &lt;&lt; arr[i] &lt;&lt; "\n";
<span class="linenr">41:  </span>    }
<span class="linenr">42:  </span>  }
</pre>




: -1
: -0.5
: 0
: 0.5
: 1

</div>
</div>

</div>

<div id="outline-container-6.2" class="outline-3">
<h3 id="sec-6.2">6.2 Header and implementation files </h3>
<div id="text-6.2">


<p>
The example in the previous section certainly made the <code>main</code> function
cleaner and simpler to understand, having only two function calls. However, 
the file itself was still pretty messy. Thankfully, there is a way to modularize 
further, by creating header and implementation files. Here is how we do it:
</p>

</div>

<div id="outline-container-6.2.1" class="outline-4">
<h4 id="sec-6.2.1">6.2.1 The header file </h4>
<div id="text-6.2.1">


<p>
Put the declarations from the into a header file, called <code>my_library.h</code>:
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  #ifndef MY_LIBRARY_H
<span class="linenr"> 2:  </span>  #define MY_LIBRARY_H
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>  #include &lt;iostream&gt;
<span class="linenr"> 5:  </span>
<span class="linenr"> 6:  </span>  namespace my_namespace {
<span class="linenr"> 7:  </span>      // `linspace` returns an array of doubles containing
<span class="linenr"> 8:  </span>      // `n_points` entries which are equally-spaced, starting
<span class="linenr"> 9:  </span>      // at `start` and ending at `stop`.
<span class="linenr">10:  </span>      double * linspace(double start, double stop, int n_points);
<span class="linenr">11:  </span>
<span class="linenr">12:  </span>      // `void` is a function with no return type.
<span class="linenr">13:  </span>      // `print_array` takes an array and prints it to std out.
<span class="linenr">14:  </span>      void print_array(double * arr, int arr_len);
<span class="linenr">15:  </span>  }
<span class="linenr">16:  </span>
<span class="linenr">17:  </span>  #endif
</pre>




<p>
Note the the function declarations are wrapped in conditional "macro" 
statments, <code>#ifndef</code>, <code>#define</code>, and <code>#endif</code>. You can think of this 
as protecting your library from being imported twice.
</p>
<p>
We have also introduced the notion of a <code>namespace</code> above. Namespaces 
help to prevent naming clashes between separate libraries. When calling 
a function from a particular namespace, you must write the namespace 
followed by <code>::</code> and then the function name. This is why many standard 
library functions like <code>&lt;iostream&gt;</code> begin with <code>std::</code>.
</p>
</div>

</div>

<div id="outline-container-6.2.2" class="outline-4">
<h4 id="sec-6.2.2">6.2.2 The implementation file </h4>
<div id="text-6.2.2">


<p>
Create a file called <code>my_library.cpp</code> containing the implementations as follows:
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  #include "my_library.h"
<span class="linenr"> 2:  </span>
<span class="linenr"> 3:  </span>  // Implementation of `linspace`.
<span class="linenr"> 4:  </span>  double * my_namespace::linspace(double start, double stop, int n_points) {
<span class="linenr"> 5:  </span>    double * arr = new double [n_points];
<span class="linenr"> 6:  </span>    double dx = (stop-start) / (n_points-1.0);
<span class="linenr"> 7:  </span>
<span class="linenr"> 8:  </span>    for(int i=0; i &lt; n_points; i++) {
<span class="linenr"> 9:  </span>      arr[i] = start + i*dx;
<span class="linenr">10:  </span>    }
<span class="linenr">11:  </span>
<span class="linenr">12:  </span>    return arr;
<span class="linenr">13:  </span>  }
<span class="linenr">14:  </span>
<span class="linenr">15:  </span>  // Implementation of `print_array`.
<span class="linenr">16:  </span>  void my_namespace::print_array(double * arr, int arr_len) {
<span class="linenr">17:  </span>    for(int i=0; i &lt; arr_len; i++) {
<span class="linenr">18:  </span>      std::cout &lt;&lt; arr[i] &lt;&lt; "\n";
<span class="linenr">19:  </span>    }
<span class="linenr">20:  </span>  }
</pre>




<p>
Note that we have to include the header file in quotations at the beginning, 
and the names of the functions must be prepended by the namespace that we've 
given in the header file.
</p>
</div>

</div>

<div id="outline-container-6.2.3" class="outline-4">
<h4 id="sec-6.2.3">6.2.3 The file containing <code>main</code> </h4>
<div id="text-6.2.3">


<p>
Create a file with the main function, say <code>main.cpp</code>:
</p>



<pre class="example">
<span class="linenr"> 1:  </span>#include &lt;iostream&gt;
<span class="linenr"> 2:  </span>#include "my_library.h"
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>int main() {
<span class="linenr"> 5:  </span>    double * xs = my_namespace::linspace(-1,1,5);
<span class="linenr"> 6:  </span>    my_namespace::print_array(xs, 5);
<span class="linenr"> 7:  </span>    delete [] xs;
<span class="linenr"> 8:  </span>
<span class="linenr"> 9:  </span>    return 0;
<span class="linenr">10:  </span>}
</pre>




<p>
Now the main function is very nice and clean, but now we 3 separate files we 
must compile into one executable. This is done as follows:
</p>



<pre class="example">
  # Convert the library into an object file.
  g++ -c my_library.cpp
  # Compile the main to an executable.
  g++ my_library.o main.cpp
  # Run it.
  ./a.out
</pre>




: -1
: -0.5
: 0
: 0.5
: 1

<p>
If successful, you will see the same output <a href="#sec-6.1">as previously</a>.
</p>
</div>
</div>

</div>

<div id="outline-container-6.3" class="outline-3">
<h3 id="sec-6.3">6.3 Function pointers </h3>
<div id="text-6.3">


<p>
Pointers can be made to functions, and these function pointers can be used 
as arguments to other functions. We'll look at two functions that accept a 
function pointer as one of their arguments.
</p>

</div>

<div id="outline-container-6.3.1" class="outline-4">
<h4 id="sec-6.3.1">6.3.1 Example: Newton's method for rootfinding </h4>
<div id="text-6.3.1">


<p>
Suppose $f: \mathbb{R} &rarr; \mathbb{R}$, and we'd like to find a root of $f$. 
Newton's method is an iterative method for finding roots, which, starting 
from some initial guess, $x<sub>0</sub>$, iterates:
</p>
<p>
$$
x<sub>n+1</sub> &larr; x<sub>n</sub> - \frac{f(x<sub>n</sub>)}{f'(x<sub>n</sub>)}
$$
</p>
<p>
For simplicity, we'll dump everything into the file containing <code>main</code>, but
you could imagine a libary with many methods for finding roots, which would 
contain Newton's method.
</p>
<p>
Let's consider $f(x) = x<sup>2</sup> - 2$.
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  #include &lt;cmath&gt;
<span class="linenr"> 2:  </span>  #include &lt;iostream&gt;
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>  // The function to find the root of.
<span class="linenr"> 5:  </span>  double func(double x);
<span class="linenr"> 6:  </span>  // Its derivative.
<span class="linenr"> 7:  </span>  double dfunc(double x);
<span class="linenr"> 8:  </span>
<span class="linenr"> 9:  </span>  // Find the root of `f` using Newton's method,
<span class="linenr">10:  </span>  // starting from `x0` until |f(x)| &lt; `tol` or `max_iters`
<span class="linenr">11:  </span>  // is reached.
<span class="linenr">12:  </span>  //
<span class="linenr">13:  </span>  // Note the first and second arguments are function pointers.
<span class="linenr">14:  </span>  double newton_root(double (*f)(double), double (*df)(double), double x0,
<span class="linenr">15:  </span>                     double tol, int max_iters, bool print_iters); 
<span class="linenr">16:  </span>
<span class="linenr">17:  </span>  int main() {
<span class="linenr">18:  </span>    double x = newton_root(&amp;func, &amp;dfunc, 1.0, 1e-6, 1000, true);
<span class="linenr">19:  </span>
<span class="linenr">20:  </span>    return 0;
<span class="linenr">21:  </span>  }
<span class="linenr">22:  </span>
<span class="linenr">23:  </span>  double func( double x) { return x*x - 2; }
<span class="linenr">24:  </span>  double dfunc(double x) { return 2*x; }
<span class="linenr">25:  </span>
<span class="linenr">26:  </span>  double newton_root(double (*f)(double), double (*df)(double), double x0,
<span class="linenr">27:  </span>                     double tol, int max_iters, bool print_iters) {
<span class="linenr">28:  </span>    double x  = x0;
<span class="linenr">29:  </span>    int iter  = 0;
<span class="linenr">30:  </span>
<span class="linenr">31:  </span>    while (std::abs(f(x)) &gt; tol &amp;&amp; iter &lt; max_iters) {
<span class="linenr">32:  </span>      if (print_iters) { 
<span class="linenr">33:  </span>        std::cout &lt;&lt; "f(" &lt;&lt; x &lt;&lt; ") = " &lt;&lt; f(x) &lt;&lt; "\n";
<span class="linenr">34:  </span>      }
<span class="linenr">35:  </span>
<span class="linenr">36:  </span>      // Newton's method update.
<span class="linenr">37:  </span>      x -= f(x) / df(x);
<span class="linenr">38:  </span>      iter++;
<span class="linenr">39:  </span>    }
<span class="linenr">40:  </span>    
<span class="linenr">41:  </span>    // One last print if necessary.
<span class="linenr">42:  </span>    if (print_iters) { 
<span class="linenr">43:  </span>      std::cout &lt;&lt; "f(" &lt;&lt; x &lt;&lt; ") = " &lt;&lt; f(x) &lt;&lt; "\n";
<span class="linenr">44:  </span>    }
<span class="linenr">45:  </span>
<span class="linenr">46:  </span>    return x;
<span class="linenr">47:  </span>  }
</pre>




: f(1) = -1
: f(1.5) = 0.25
: f(1.41667) = 0.00694444
: f(1.41422) = 6.0073e-06
: f(1.41421) = 4.51061e-12

</div>

</div>

<div id="outline-container-6.3.2" class="outline-4">
<h4 id="sec-6.3.2">6.3.2 Example: The midpoint rule for definite integrals </h4>
<div id="text-6.3.2">


<p>
The midpoint rule is a numerical integration method which approximates 
the definite integral of a specified function over a specified interval 
using a specified number of subintervals where on each subinterval, the 
area under the curve is approximated by a rectangle whose width is the 
width of the subinterval and whose height is the height of the function 
at the midpoint between the points defining the end points of the subinterval.
</p>
<p>
Specifically, if $n$ equally-sized subintervals are used on $[a,b]$, then
the midpoint rule approximation, $M<sub>n</sub>$, to the definite integral of $f(x)$ 
on $[a,b]$ is: 
</p>
<p>
$$
&int;<sub>a</sub><sup>b</sup> f(x) \; dx &asymp; &sum;<sub>i=1</sub><sup>n</sup> f\left( \frac{x<sub>i-1</sub>+x<sub>i</sub>}{2} \right) &Delta; x =: M<sub>n</sub>
$$
</p>
<p>
where $&Delta; x = \frac{b-a}{n}$, and $x<sub>i</sub> = a + i &sdot; &Delta; x, \;\; i=0, 1, \ldots, n$.
</p>
<p>
Let's consider $f(x) = \frac{1}{x}$ on $[1, e]$.
</p>



<pre class="example">
<span class="linenr"> 1:  </span>  #include &lt;iostream&gt;
<span class="linenr"> 2:  </span>  #include &lt;cmath&gt;
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>  const double E = std::exp(1.0);
<span class="linenr"> 5:  </span>
<span class="linenr"> 6:  </span>  // The function to be integrated.
<span class="linenr"> 7:  </span>  double func(double x);
<span class="linenr"> 8:  </span>
<span class="linenr"> 9:  </span>  // Compute the midpoint rule approximation to
<span class="linenr">10:  </span>  // the definite integral of `f` from `a` to `b`
<span class="linenr">11:  </span>  // using `n` subintervals.
<span class="linenr">12:  </span>  double midpoint_rule(double (*f)(double), double a, double b, int n);
<span class="linenr">13:  </span>
<span class="linenr">14:  </span>
<span class="linenr">15:  </span>  int main() {
<span class="linenr">16:  </span>    for(int n=2; n &lt;= 20; n += 2) {
<span class="linenr">17:  </span>      std::cout &lt;&lt; "n = " &lt;&lt; n &lt;&lt; ", "
<span class="linenr">18:  </span>                &lt;&lt; "M_n = " &lt;&lt; midpoint_rule(&amp;func, 1, E, n) &lt;&lt; "\n";
<span class="linenr">19:  </span>    }
<span class="linenr">20:  </span>
<span class="linenr">21:  </span>    return 0;
<span class="linenr">22:  </span>  }
<span class="linenr">23:  </span>
<span class="linenr">24:  </span>  double func(double x) { return 1.0 / x; }
<span class="linenr">25:  </span>
<span class="linenr">26:  </span>  double midpoint_rule(double (*f)(double), double a, double b, int n) {
<span class="linenr">27:  </span>    double xi;
<span class="linenr">28:  </span>    double xi_prev = a;
<span class="linenr">29:  </span>    double dx = (b-a) / n;
<span class="linenr">30:  </span>    double sum;
<span class="linenr">31:  </span>
<span class="linenr">32:  </span>    for(int i=1; i &lt;= n; i++) {
<span class="linenr">33:  </span>      xi = a + i*dx;
<span class="linenr">34:  </span>      sum += f(0.5*(xi_prev + xi));
<span class="linenr">35:  </span>      xi_prev = xi;
<span class="linenr">36:  </span>    }
<span class="linenr">37:  </span>
<span class="linenr">38:  </span>    return sum*dx;
<span class="linenr">39:  </span>  }
</pre>





<pre class="example">
n = 2, M_n = 0.97636
n = 4, M_n = 0.993575
n = 6, M_n = 0.997091
n = 8, M_n = 0.998353
n = 10, M_n = 0.998942
n = 12, M_n = 0.999264
n = 14, M_n = 0.999459
n = 16, M_n = 0.999585
n = 18, M_n = 0.999672
n = 20, M_n = 0.999734
</pre>




</div>
</div>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">7 Object-oriented programming </h2>
<div id="text-7">


<p>
New data types can be created by writing a new <code>class</code>. A <code>class</code> has 
state variables and functions that act on the state variables. An instance 
of a <code>class</code> is called an <b>object</b>. Let's write a <code>vector</code> class that 
improves upon the default <code>double</code> array.
</p>

</div>

<div id="outline-container-7.1" class="outline-3">
<h3 id="sec-7.1">7.1 Example: a vector <code>class</code> </h3>
<div id="text-7.1">



</div>

<div id="outline-container-7.1.1" class="outline-4">
<h4 id="sec-7.1.1">7.1.1 The header file </h4>
<div id="text-7.1.1">


<p>
Create the header file, <code>vector.h</code>:
</p>



<pre class="example">
<span class="linenr"> 1:  </span>#ifndef VECTOR_H
<span class="linenr"> 2:  </span>#define VECTOR_H
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>namespace vec {
<span class="linenr"> 5:  </span>  class vector {
<span class="linenr"> 6:  </span>  public:
<span class="linenr"> 7:  </span>    // Constructor. This function is called when the object is created.
<span class="linenr"> 8:  </span>    vector(unsigned len);
<span class="linenr"> 9:  </span>
<span class="linenr">10:  </span>    // Destructor. This function is called when the object is destroyed.
<span class="linenr">11:  </span>    ~vector();
<span class="linenr">12:  </span>
<span class="linenr">13:  </span>    // length accessor.
<span class="linenr">14:  </span>    unsigned len();
<span class="linenr">15:  </span>
<span class="linenr">16:  </span>    // data accessor.
<span class="linenr">17:  </span>    double &amp; element(unsigned i);
<span class="linenr">18:  </span>
<span class="linenr">19:  </span>    // Simple print function.
<span class="linenr">20:  </span>    void print();
<span class="linenr">21:  </span>
<span class="linenr">22:  </span>  private:
<span class="linenr">23:  </span>    unsigned length;
<span class="linenr">24:  </span>    double * data;
<span class="linenr">25:  </span>    void check_index(unsigned i);
<span class="linenr">26:  </span>  };
<span class="linenr">27:  </span>}
<span class="linenr">28:  </span>#endif
</pre>




<p>
First note the macro guards, <code>#ifndef</code>, <code>#define</code>, and <code>#endif</code>, as well as the 
namespace, <code>vec</code>, wrapping the <code>class</code> declaration. Macro guards and namespaces 
were previously discussed when we initially introduced 
<a href="#sec-6.2">how to write header and implementation files</a>. 
</p>
<p>
Now, within the namespace, we've declared a class, <code>vector</code>, which 
contains <code>public</code> and <code>private</code> variables and function declarations. Private 
functions and variables may only be accessed through the public methods. This 
means if you created an instance of the class, <code>vector</code>, you would not be able 
to access the private variable directly. You could only call the <b>public  member-functions</b>, which, in turn, may manipulate the 
<b>private member-variables</b>, or call the <b>private member-functions</b>. 
Splitting variables and functions into public and private helps to ensure 
that other libraries and programs use your class as intended.
</p>
<p>
Thus far, this class has 5 public member-functions, 2 private member-variables, 
and 1 private member-function. The first two member functions are special, 
the <b>constructor</b> and <b>destructor</b>, respectively. The constructor is called 
explicitly when you declare a new instance of this class, while the destructor 
is usually called implicitly when the object is deleted or when it goes out of 
scope.
</p>
<p>
Notice that the method for accessing elements of <code>vector</code> is called <code>element</code> 
and its return type is a <b>reference</b> (<a href="#sec-1">discussed previously</a>). This allows us 
to use this function on both the left side of assignment operators, i.e., to 
assign values to <code>vector</code> components, and on the right side of assignments, 
i.e., to treat it as the value of the component.
</p>
</div>

</div>

<div id="outline-container-7.1.2" class="outline-4">
<h4 id="sec-7.1.2">7.1.2 The implementation file </h4>
<div id="text-7.1.2">


<p>
Create the implementation file, <code>vector.cpp</code>:
</p>



<pre class="example">
<span class="linenr"> 1:  </span>#include &lt;iostream&gt;
<span class="linenr"> 2:  </span>#include &lt;cstdlib&gt;
<span class="linenr"> 3:  </span>#include "vector.h"
<span class="linenr"> 4:  </span>
<span class="linenr"> 5:  </span>namespace vec {
<span class="linenr"> 6:  </span>  vector::vector(unsigned len) {
<span class="linenr"> 7:  </span>    this-&gt;length = len;
<span class="linenr"> 8:  </span>    this-&gt;data = new double[len];
<span class="linenr"> 9:  </span>    // Initialize data to zeros.
<span class="linenr">10:  </span>    for(int i=0; i &lt; this-&gt;len(); i++) { this-&gt;data[i] = 0.0; }
<span class="linenr">11:  </span>  }
<span class="linenr">12:  </span>
<span class="linenr">13:  </span>  vector::~vector() {
<span class="linenr">14:  </span>    delete [] this-&gt;data;
<span class="linenr">15:  </span>  }
<span class="linenr">16:  </span>
<span class="linenr">17:  </span>  unsigned vector::len() {
<span class="linenr">18:  </span>    return this-&gt;length;
<span class="linenr">19:  </span>  }
<span class="linenr">20:  </span>
<span class="linenr">21:  </span>  double &amp; vector::element(unsigned i) {
<span class="linenr">22:  </span>    #ifndef NDEBUG
<span class="linenr">23:  </span>    check_index(i);
<span class="linenr">24:  </span>    #endif
<span class="linenr">25:  </span>    return this-&gt;data[i];
<span class="linenr">26:  </span>  }
<span class="linenr">27:  </span>
<span class="linenr">28:  </span>  void vector::print() {
<span class="linenr">29:  </span>    for(int i=0; i &lt; this-&gt;len(); i++) {
<span class="linenr">30:  </span>      std::cout &lt;&lt; this-&gt;data[i] &lt;&lt; '\n';
<span class="linenr">31:  </span>    }
<span class="linenr">32:  </span>  }
<span class="linenr">33:  </span>
<span class="linenr">34:  </span>  void vector::check_index(unsigned i) {
<span class="linenr">35:  </span>    if (i &lt; 0 || i &gt;= this-&gt;length) {
<span class="linenr">36:  </span>      std::cerr &lt;&lt; "ERROR: index, " &lt;&lt; i &lt;&lt; ", is out-of-bounds.\n"
<span class="linenr">37:  </span>                &lt;&lt; "(valid indices are 0-" &lt;&lt; (this-&gt;length-1) &lt;&lt; ")\n";
<span class="linenr">38:  </span>      exit(1);
<span class="linenr">39:  </span>    }
<span class="linenr">40:  </span>  }
<span class="linenr">41:  </span>}
</pre>




<p>
Note that we again wrap the implementations in the same namespace as wrapped 
by the class declaration. Also observe how each member-function is prepended 
by <code>vector::</code>.
</p>
<p>
The keyword, <code>this</code>, is a pointer to the calling object. Writing, <code>this-&gt;</code>,
is equivalent to <code>(*this).</code>, and in fact, can be used for any pointer. Thus,
<code>this-&gt;length</code> is equivalent to <code>(*this).length</code>.
</p>
<p>
Observe how the private member function, <code>check_index</code>, is used in the 
public <code>element</code> accessor function. If this library is compiled with the 
flag, <code>-DNEDUBG</code>, then the check function will not be called. You could 
read this flag as "define no debug". Thus, when this flag is present, the 
debug function <code>check_index</code> is called whenever the element accessor is 
called. The <code>check_index</code> function simply checks if the provided index is 
out-of-bounds for the vector. If it is, an informative message is printed, 
and the program terminates prematurely by calling <code>exit(1)</code>. Such assertions 
with informative messages are a good practice, and will likely save you lots 
of headaches in the future.
</p>
</div>

</div>

<div id="outline-container-7.1.3" class="outline-4">
<h4 id="sec-7.1.3">7.1.3 Example usage </h4>
<div id="text-7.1.3">


<p>
Ok. Let's see some example usage, by creating a <code>main.cpp</code>, containing:
</p>



<pre class="example">
<span class="linenr"> 1:  </span>#include &lt;iostream&gt;
<span class="linenr"> 2:  </span>#include "vector.h"
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>int main() {
<span class="linenr"> 5:  </span>    vec::vector v(5);
<span class="linenr"> 6:  </span>
<span class="linenr"> 7:  </span>    std::cout &lt;&lt; "`v` has length = " &lt;&lt; v.len() &lt;&lt; "\n";
<span class="linenr"> 8:  </span>
<span class="linenr"> 9:  </span>    v.element(0) = -1.27;
<span class="linenr">10:  </span>    v.element(3) = 3.1;
<span class="linenr">11:  </span>
<span class="linenr">12:  </span>    v.print();
<span class="linenr">13:  </span>
<span class="linenr">14:  </span>    v.element(5) = 1234.0;
<span class="linenr">15:  </span>
<span class="linenr">16:  </span>    return 0;
<span class="linenr">17:  </span>}
</pre>




<p>
Let's first compile with our <code>check_index</code> debugger function in place:
</p>



<pre class="example">
  g++ -c vector.cpp
  g++ vector.o main.cpp
  ./a.out
</pre>




<p>
If successful, you should see:
</p>
<pre class="example">
`v` has length = 5
-1.27
0
0
3.1
0
ERROR: index, 5, is out-of-bounds.
(valid indices are 0-4)
</pre>

<p>
Now let's run without <code>check_index</code>:
</p>



<pre class="example">
  g++ -DNDEBUG -c vector.cpp
  g++ vector.o main.cpp
  ./a.out
</pre>




<p>
Upon running, you will likely see some extensive list of errors when 
the element beyond the array's length is attempted to be accessed. Again, 
by liberally sprinkling these sorts of assertions through your code, you 
will (sometimes) find debugging much easier. After you're fairly certain 
that your code is working, you can simply compile with <code>-DNEDUBG</code>.
</p>
</div>
</div>

</div>

<div id="outline-container-7.2" class="outline-3">
<h3 id="sec-7.2">7.2 Example cont'd: operator overloading </h3>
<div id="text-7.2">


<p>
The <code>v.element(i)</code> accessor is a bit clunky. We can replace this with the 
more natural, <code>v[i]</code>, by <b>overloading</b> the <code>[]</code> operator. Indeed,
<a href="http://en.cppreference.com/w/cpp/language/operators">we can overload many</a> of the normal C++ operators, e.g. <code>+</code>, <code>-</code>, ===, etc.
</p>

</div>

<div id="outline-container-7.2.1" class="outline-4">
<h4 id="sec-7.2.1">7.2.1 Overloading <code>operator[]</code> </h4>
<div id="text-7.2.1">


<p>
In the header file, replace the <code>element</code> function declaration with:
</p>

<p>
namespace vec {
class vector {
public:
// Constructor. This function is called when the object is created.
vector(unsigned len);
</p>
<p>
// Destructor. This function is called when the object is destroyed.
~vector();
</p>
<p>
// length accessor.
unsigned len();
</p>
<p>
// data accessor.
double &amp; operator[](unsigned i);
</p>
<p>
// assignment operator.
vector &amp; operator=(vector &amp; src);
</p>
<p>
// Simple print function.
void print();
</p>
<p>
private:
unsigned length;
double * data;
void check<sub>index</sub>(unsigned i);
};
}
</p>
<p>
and in the implementation file, replace the <code>element</code> implementation with:
</p>

<p>
namespace vec {
vector::vector(unsigned len) {
this-&gt;length = len;
this-&gt;data = new double[len];
// Initialize data to zeros.
for(int i=0; i &lt; this-&gt;len(); i++) { this-&gt;data[i] = 0.0; }
}
</p>
<p>
vector::~vector() {
delete [] this-&gt;data;
}
</p>
<p>
unsigned vector::len() {
return this-&gt;length;
}
</p>
<p>
double &amp; vector::operator[](unsigned i) {
#ifndef NDEBUG
check<sub>index</sub>(i);
#endif
return this-&gt;data[i];
}
</p>
<p>
vector &amp; vector::operator=(vector &amp; src) {
// Delete the old data.
delete [] this-&gt;data;
</p>
<p>
// Initialize the new data.
this-&gt;length = src.len();
this-&gt;data = new double[this-&gt;len()];
</p>
<p>
// Copy over the new data.
for(int i=0; i &lt; this-&gt;len(); i++) {
this-&gt;data[i] = src[i];
}
</p>
<p>
return *this;
}
</p>
<p>
void vector::print() {
for(int i=0; i &lt; this-&gt;len(); i++) {
std::cout &lt;&lt; this-&gt;data[i] &lt;&lt; '\n';
}
}
</p>
<p>
void vector::check<sub>index</sub>(unsigned i) {
if (i &lt; 0 || i &gt;= this-&gt;length) {
std::cerr &lt;&lt; "ERROR: index, " &lt;&lt; i &lt;&lt; ", is out-of-bounds.\n"
&lt;&lt; "(valid indices are 0-" &lt;&lt; (this-&gt;length-1) &lt;&lt; ")\n";
exit(1);
}
}
}
</p>
<p>
Just think of <code>operator[]</code> as the new name of the function, <code>element</code>. We 
can now use the overloaded operator just like how we would use the <code>[]</code> for 
operator for accessing array components, expect now our overloaded operator 
function is called instead.
</p>

<p>
int main() {
vec::vector v(5);
</p>
<p>
v<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup> = -1.27;
v<sup><a class="footref" name="fnr.2" href="#fn.2">2</a></sup> = 3.1;
</p>
<p>
vec::vector w(14);
w = v;
w.print();
</p>
<p>
return 0;
}
</p>
<p>
Compile and run:
</p>



<pre class="example">
  g++ -c vector.cpp &amp;&amp; g++ vector.o main.cpp &amp;&amp; ./a.out
</pre>




<p>
and you should see:
</p>
<pre class="example">
-1.27
0
0
3.1
0
</pre>

<p>
just like before.
</p>
</div>

</div>

<div id="outline-container-7.2.2" class="outline-4">
<h4 id="sec-7.2.2">7.2.2 Overloading <code>operator=</code> </h4>
<div id="text-7.2.2">


<p>
Let's overload the <code>=</code> operator so we can assign one vector to another. 
We'll write in a way such that the vector on the left hand side is 
overwritten by the one on the right.
</p>
<p>
Let's add a declaration to the header file,
</p>

<p>
namespace vec {
class vector {
public:
// Constructor. This function is called when the object is created.
vector(unsigned len);
</p>
<p>
// Destructor. This function is called when the object is destroyed.
~vector();
</p>
<p>
// length accessor.
unsigned len();
</p>
<p>
// data accessor.
double &amp; operator[](unsigned i);
</p>
<p>
// assignment operator.
vector &amp; operator=(vector &amp; src);
</p>
<p>
// Simple print function.
void print();
</p>
<p>
private:
unsigned length;
double * data;
void check<sub>index</sub>(unsigned i);
};
}
</p>
<p>
and let's add to the implementation file,
</p>

<p>
namespace vec {
vector::vector(unsigned len) {
this-&gt;length = len;
this-&gt;data = new double[len];
// Initialize data to zeros.
for(int i=0; i &lt; this-&gt;len(); i++) { this-&gt;data[i] = 0.0; }
}
</p>
<p>
vector::~vector() {
delete [] this-&gt;data;
}
</p>
<p>
unsigned vector::len() {
return this-&gt;length;
}
</p>
<p>
double &amp; vector::operator[](unsigned i) {
#ifndef NDEBUG
check<sub>index</sub>(i);
#endif
return this-&gt;data[i];
}
</p>
<p>
vector &amp; vector::operator=(vector &amp; src) {
// Delete the old data.
delete [] this-&gt;data;
</p>
<p>
// Initialize the new data.
this-&gt;length = src.len();
this-&gt;data = new double[this-&gt;len()];
</p>
<p>
// Copy over the new data.
for(int i=0; i &lt; this-&gt;len(); i++) {
this-&gt;data[i] = src[i];
}
</p>
<p>
return *this;
}
</p>
<p>
void vector::print() {
for(int i=0; i &lt; this-&gt;len(); i++) {
std::cout &lt;&lt; this-&gt;data[i] &lt;&lt; '\n';
}
}
</p>
<p>
void vector::check<sub>index</sub>(unsigned i) {
if (i &lt; 0 || i &gt;= this-&gt;length) {
std::cerr &lt;&lt; "ERROR: index, " &lt;&lt; i &lt;&lt; ", is out-of-bounds.\n"
&lt;&lt; "(valid indices are 0-" &lt;&lt; (this-&gt;length-1) &lt;&lt; ")\n";
exit(1);
}
}
}
</p>
<p>
Now, let's assume the <code>vector</code> instance, <code>v</code>, from above is still defined, and
we'll create a new vector:
</p>

<p>
int main() {
vec::vector v(5);
</p>
<p>
v<sup><a class="footref" name="fnr.1.2" href="#fn.1">1</a></sup> = -1.27;
v<sup><a class="footref" name="fnr.2.2" href="#fn.2">2</a></sup> = 3.1;
</p>
<p>
vec::vector w(14);
w = v;
w.print();
</p>
<p>
return 0;
}
</p>
<p>
This should print, 
</p>
<pre class="example">
-1.27
0
0
3.1
0
</pre>

<p>
Notice that <code>w</code> is intially defined to be of length <code>14</code>, but this is 
overwritten, and its new length is the length of <code>v</code>. Also note that all of
<code>w</code>'s old data is deleted.
</p>
</div>
</div>

</div>

<div id="outline-container-7.3" class="outline-3">
<h3 id="sec-7.3">7.3 Example cont'd: the copy constructor </h3>
<div id="text-7.3">


<p>
It may be tempting at this point to attempt to initialize <code>w</code> from <code>v</code>
directly:
</p>



<pre class="example">
<span class="linenr">1:  </span>  vec::vector w = v;
</pre>




<p>
If you attempt this currently, you will see all sorts of errors. This is 
because this type of intialization does not call the assignment operator. 
It calls the <b>copy constructor</b>. The assignment operator is only called 
when the object has already been intialized. Writing the previous line of 
code is essentially equivalent to
</p>



<pre class="example">
<span class="linenr">1:  </span>  vec::vector w(v);
</pre>




<p>
In other words, the constructor is called with the existing vector, <code>v</code>, as
the argument, but we have not written a constructor yet with such a call 
signature.
</p>
<p>
The constructor can be overloaded, i.e., we can write multiple versions of the 
constructor function, and the one that matches the correct call signature will 
be used. This function overloading behavior actually applies to all functions 
in C++.
</p>
<p>
Let's add the copy constructor declaration to the header file:
</p>

<p>
namespace vec {
class vector {
public:
// Constructor. This function is called when the object is created.
vector(unsigned len);
</p>
<p>
// Copy constructor.
vector(vector &amp; src);
</p>
<p>
// Destructor. This function is called when the object is destroyed.
~vector();
</p>
<p>
// length accessor.
unsigned len();
</p>
<p>
// data accessor.
double &amp; operator[](unsigned i);
</p>
<p>
// assignment operator.
vector &amp; operator=(vector &amp; src);
</p>
<p>
// Simple print function.
void print();
</p>
<p>
private:
unsigned length;
double * data;
void check<sub>index</sub>(unsigned i);
};
}
</p>
<p>
and let's add its implementation:
</p>

<p>
namespace vec {
vector::vector(unsigned len) {
this-&gt;length = len;
this-&gt;data = new double[len];
// Initialize data to zeros.
for(int i=0; i &lt; this-&gt;len(); i++) { this-&gt;data[i] = 0.0; }
}
</p>
<p>
vector::vector(vector &amp; src) {
this-&gt;length = src.len();
this-&gt;data = new double[this-&gt;len()];
</p>
<p>
// Copy over the data.
for(int i=0; i &lt; this-&gt;len(); i++) {
this-&gt;data[i] = src[i];
}
}
</p>
<p>
vector::~vector() {
delete [] this-&gt;data;
}
</p>
<p>
unsigned vector::len() {
return this-&gt;length;
}
</p>
<p>
double &amp; vector::operator[](unsigned i) {
#ifndef NDEBUG
check<sub>index</sub>(i);
#endif
return this-&gt;data[i];
}
</p>
<p>
vector &amp; vector::operator=(vector &amp; src) {
// Delete the old data.
delete [] this-&gt;data;
</p>
<p>
// Initialize the new data.
this-&gt;length = src.len();
this-&gt;data = new double[this-&gt;len()];
</p>
<p>
// Copy over the new data.
for(int i=0; i &lt; this-&gt;len(); i++) {
this-&gt;data[i] = src[i];
}
</p>
<p>
return *this;
}
</p>
<p>
void vector::print() {
for(int i=0; i &lt; this-&gt;len(); i++) {
std::cout &lt;&lt; this-&gt;data[i] &lt;&lt; '\n';
}
}
</p>
<p>
void vector::check<sub>index</sub>(unsigned i) {
if (i &lt; 0 || i &gt;= this-&gt;length) {
std::cerr &lt;&lt; "ERROR: index, " &lt;&lt; i &lt;&lt; ", is out-of-bounds.\n"
&lt;&lt; "(valid indices are 0-" &lt;&lt; (this-&gt;length-1) &lt;&lt; ")\n";
exit(1);
}
}
}
</p>
<p>
Now we compile and run something like:
</p>

<p>
int main() {
vec::vector v(5);
</p>
<p>
v<sup><a class="footref" name="fnr.1.3" href="#fn.1">1</a></sup> = -1.27;
v<sup><a class="footref" name="fnr.2.3" href="#fn.2">2</a></sup> = 3.1;
</p>
<p>
vec::vector w = v;
w.print();
</p>
<p>
return 0;
}
</p>
<p>
we will see:
</p>
<pre class="example">
-1.27
0
0
3.1
0
</pre>

</div>

</div>

<div id="outline-container-7.4" class="outline-3">
<h3 id="sec-7.4">7.4 Exampled cont'd: more overloading - <code>operator+</code> </h3>
<div id="text-7.4">


<p>
Let's overload the <code>+</code> operator so we can add two vectors. First add to 
the header file:
</p>

<p>
namespace vec {
class vector {
public:
// Constructor. This function is called when the object is created.
vector(unsigned len);
</p>
<p>
// Copy constructor.
vector(vector &amp; src);
</p>
<p>
// Destructor. This function is called when the object is destroyed.
~vector();
</p>
<p>
// length accessor.
unsigned len();
</p>
<p>
// data accessor.
double &amp; operator[](unsigned i);
</p>
<p>
// assignment operator.
vector &amp; operator=(vector &amp; src);
</p>
<p>
// Arithmetic operators&hellip;
vector &amp; operator+(vector &amp; src);
</p>
<p>
// Simple print function.
void print();
</p>
<p>
private:
unsigned length;
double * data;
void check<sub>index</sub>(unsigned i);
void check<sub>same</sub><sub>len</sub>(vector &amp; src);
};
}
</p>
<p>
also add:
</p>

<p>
namespace vec {
class vector {
public:
// Constructor. This function is called when the object is created.
vector(unsigned len);
</p>
<p>
// Copy constructor.
vector(vector &amp; src);
</p>
<p>
// Destructor. This function is called when the object is destroyed.
~vector();
</p>
<p>
// length accessor.
unsigned len();
</p>
<p>
// data accessor.
double &amp; operator[](unsigned i);
</p>
<p>
// assignment operator.
vector &amp; operator=(vector &amp; src);
</p>
<p>
// Arithmetic operators&hellip;
vector &amp; operator+(vector &amp; src);
</p>
<p>
// Simple print function.
void print();
</p>
<p>
private:
unsigned length;
double * data;
void check<sub>index</sub>(unsigned i);
void check<sub>same</sub><sub>len</sub>(vector &amp; src);
};
}
</p>
<p>
to the list of private declarations in <code>vector.h</code>
</p>
<p>
Next, let's add the implementation of these two functions:
</p>

<p>
namespace vec {
vector::vector(unsigned len) {
this-&gt;length = len;
this-&gt;data = new double[len];
// Initialize data to zeros.
for(int i=0; i &lt; this-&gt;len(); i++) { this-&gt;data[i] = 0.0; }
}
</p>
<p>
vector::vector(vector &amp; src) {
this-&gt;length = src.len();
this-&gt;data = new double[this-&gt;len()];
</p>
<p>
// Copy over the data.
for(int i=0; i &lt; this-&gt;len(); i++) {
this-&gt;data[i] = src[i];
}
}
</p>
<p>
vector::~vector() {
delete [] this-&gt;data;
}
</p>
<p>
unsigned vector::len() {
return this-&gt;length;
}
</p>
<p>
double &amp; vector::operator[](unsigned i) {
#ifndef NDEBUG
check<sub>index</sub>(i);
#endif
return this-&gt;data[i];
}
</p>
<p>
vector &amp; vector::operator=(vector &amp; src) {
// Delete the old data.
delete [] this-&gt;data;
</p>
<p>
// Initialize the new data.
this-&gt;length = src.len();
this-&gt;data = new double[this-&gt;len()];
</p>
<p>
// Copy over the new data.
for(int i=0; i &lt; this-&gt;len(); i++) {
this-&gt;data[i] = src[i];
}
</p>
<p>
return *this;
}
</p>
<p>
vector &amp; vector::operator+(vector &amp; src) {
#ifndef NDEBUG
this-&gt;check<sub>same</sub><sub>len</sub>(src);
#endif
</p>
<p>
vector * result = new vector(this-&gt;len());
</p>
<p>
for(int i=0; i &lt; this-&gt;len(); i++) {
result-&gt;data[i] = this-&gt;data[i] + src[i];
}
</p>
<p>
return *result;
}
</p>
<p>
void vector::print() {
for(int i=0; i &lt; this-&gt;len(); i++) {
std::cout &lt;&lt; this-&gt;data[i] &lt;&lt; '\n';
}
}
</p>
<p>
void vector::check<sub>index</sub>(unsigned i) {
if (i &lt; 0 || i &gt;= this-&gt;length) {
std::cerr &lt;&lt; "ERROR: index, " &lt;&lt; i &lt;&lt; ", is out-of-bounds.\n"
&lt;&lt; "(valid indices are 0-" &lt;&lt; (this-&gt;length-1) &lt;&lt; ")\n";
exit(1);
}
}
</p>
<p>
void vector::check<sub>same</sub><sub>len</sub>(vector &amp; src) {
if (this-&gt;len() != src.len()) {
std::cerr &lt;&lt; "ERROR: length mismatch.\n"
&lt;&lt; "(left len: " &lt;&lt; this-&gt;len() &lt;&lt; ", "
&lt;&lt; "right len: " &lt;&lt; src.len() &lt;&lt; ")\n";
exit(1);
}
}
}
</p>

<p>
namespace vec {
vector::vector(unsigned len) {
this-&gt;length = len;
this-&gt;data = new double[len];
// Initialize data to zeros.
for(int i=0; i &lt; this-&gt;len(); i++) { this-&gt;data[i] = 0.0; }
}
</p>
<p>
vector::vector(vector &amp; src) {
this-&gt;length = src.len();
this-&gt;data = new double[this-&gt;len()];
</p>
<p>
// Copy over the data.
for(int i=0; i &lt; this-&gt;len(); i++) {
this-&gt;data[i] = src[i];
}
}
</p>
<p>
vector::~vector() {
delete [] this-&gt;data;
}
</p>
<p>
unsigned vector::len() {
return this-&gt;length;
}
</p>
<p>
double &amp; vector::operator[](unsigned i) {
#ifndef NDEBUG
check<sub>index</sub>(i);
#endif
return this-&gt;data[i];
}
</p>
<p>
vector &amp; vector::operator=(vector &amp; src) {
// Delete the old data.
delete [] this-&gt;data;
</p>
<p>
// Initialize the new data.
this-&gt;length = src.len();
this-&gt;data = new double[this-&gt;len()];
</p>
<p>
// Copy over the new data.
for(int i=0; i &lt; this-&gt;len(); i++) {
this-&gt;data[i] = src[i];
}
</p>
<p>
return *this;
}
</p>
<p>
vector &amp; vector::operator+(vector &amp; src) {
#ifndef NDEBUG
this-&gt;check<sub>same</sub><sub>len</sub>(src);
#endif
</p>
<p>
vector * result = new vector(this-&gt;len());
</p>
<p>
for(int i=0; i &lt; this-&gt;len(); i++) {
result-&gt;data[i] = this-&gt;data[i] + src[i];
}
</p>
<p>
return *result;
}
</p>
<p>
void vector::print() {
for(int i=0; i &lt; this-&gt;len(); i++) {
std::cout &lt;&lt; this-&gt;data[i] &lt;&lt; '\n';
}
}
</p>
<p>
void vector::check<sub>index</sub>(unsigned i) {
if (i &lt; 0 || i &gt;= this-&gt;length) {
std::cerr &lt;&lt; "ERROR: index, " &lt;&lt; i &lt;&lt; ", is out-of-bounds.\n"
&lt;&lt; "(valid indices are 0-" &lt;&lt; (this-&gt;length-1) &lt;&lt; ")\n";
exit(1);
}
}
</p>
<p>
void vector::check<sub>same</sub><sub>len</sub>(vector &amp; src) {
if (this-&gt;len() != src.len()) {
std::cerr &lt;&lt; "ERROR: length mismatch.\n"
&lt;&lt; "(left len: " &lt;&lt; this-&gt;len() &lt;&lt; ", "
&lt;&lt; "right len: " &lt;&lt; src.len() &lt;&lt; ")\n";
exit(1);
}
}
}
</p>
<p>
Note how we create the <code>result</code> vector in <code>operator+</code> as a pointer, and then 
we deference it when its returned. This matches the return type of the function, 
which should a reference type. Next, note how we've again added a macro guard, 
around the <code>check_same_len</code> function, which will allow this safeguard to be 
skipped by adding the <code>-DNDEBUG</code> flag during compile time.
</p>
<p>
Let's look at an example usage where 
</p>



<pre class="example">
<span class="linenr"> 1:  </span>#include &lt;iostream&gt;
<span class="linenr"> 2:  </span>#include "vector.h"
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>int main() {
<span class="linenr"> 5:  </span>    vec::vector v(5);
<span class="linenr"> 6:  </span>
<span class="linenr"> 7:  </span>    v[0] = -1.27;
<span class="linenr"> 8:  </span>    v[3] = 3.1;
<span class="linenr"> 9:  </span>
<span class="linenr">10:  </span>    vec::vector w = v;
<span class="linenr">11:  </span>
<span class="linenr">12:  </span>    vec::vector z = w+v;
<span class="linenr">13:  </span>    z.print();
<span class="linenr">14:  </span>
<span class="linenr">15:  </span>    vec::vector q(6);
<span class="linenr">16:  </span>    q+v;
<span class="linenr">17:  </span>
<span class="linenr">18:  </span>    return 0;
<span class="linenr">19:  </span>}
</pre>




<p>
This will print the sum for <code>z</code>, but it will error when we add <code>q</code> and <code>z</code>:
</p>
<pre class="example">
-2.54
0
0
6.2
0
ERROR: length mismatch.
(left len: 6, right len: 5)
</pre>



</div>



</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> FOOTNOTE DEFINITION NOT FOUND: 0
</p>
<p class="footnote"><sup><a class="footnum" name="fn.2" href="#fnr.2">2</a></sup> FOOTNOTE DEFINITION NOT FOUND: 3
</p>
</div>
</div>
<div id="postamble"><p class="author"> Author: Matt Hancock
<a href="mailto:mhancock@compute4.math.fsu.edu">&lt;mhancock@compute4.math.fsu.edu&gt;</a>
</p>
<p class="date"> Date:  </p>
<p>HTML generated by org-mode 6.21b in emacs 23</p>
</div></body>
</html>
